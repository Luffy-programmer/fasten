/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin;

import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.analyzer.vulnerabilityplugin.utils.JavaHttpClient;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Parser;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import org.apache.commons.io.FileUtils;
import org.bson.BSON;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.owasp.dependencycheck.data.nvd.json.DefCveItem;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static com.mongodb.client.model.Filters.and;
import static com.mongodb.client.model.Filters.eq;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

public class ParserTest {

    // Inject Java Http Client to test
    JavaHttpClient clientMock = Mockito.mock(JavaHttpClient.class);

    // Inject mock database in order to test
    MongoDatabase dbMock = Mockito.mock(MongoDatabase.class);
    MongoCollection<Document> commitsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> prsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> issuesMock = Mockito.mock(MongoCollection.class);
    private Parser parser;

    static final String validJSON = "{" +
            "\"comment\":\"Testing\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"Retrieve Relevant files\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[]," +
            "\"master_commit\":{" +
                "\"commit_hash\":\"hash\"," +
                "\"commit_link\":\"https://github.com/generic_commit\"," +
                "\"relevant_files\":[\"./src/index.c\",\"./src/mock.c\"]," +
                "\"repo_name\":\"test\"," +
                "\"repo_owner\":\"random\"," +
                "\"repo_url\":\"" +
            "\"}," +
            "\"products\":[]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String emptyMasterCommit = "{" +
            "\"comment\":\"Testing JSON body valid\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"n/a\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[\"ANY\"]," +
            "\"master_commit\":{}," +
            "\"products\":[{\"product\":\"python\",\"vendor\":\"python\"}]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String errorJSON = "{\"code\":404,\"error\":\"Not found\"}";

    @BeforeEach
    public void setup() {
        when(dbMock.getCollection("commits")).thenReturn(commitsMock);
        when(dbMock.getCollection("pull_requests")).thenReturn(prsMock);
        when(dbMock.getCollection("issues")).thenReturn(issuesMock);
        parser = new Parser(dbMock, clientMock);
    }

    @Test
    public void getRelevantFilesValidJson() throws Exception {
        when(clientMock.sendGet("https://www.vulncode-db.com/api/v1/testing-valid")).thenReturn(validJSON);
        List<String> files = new ArrayList<String>();
        files.add("./src/index.c"); files.add("./src/mock.c");
        assertEquals(files, parser.getRelevantFiles("testing-valid"));
    }

    @Test
    public void getRelevantFilesEmptyJson() throws Exception {
        when(clientMock.sendGet("https://www.vulncode-db.com/api/v1/testing-empty")).thenReturn(emptyMasterCommit);
        var files = new ArrayList<String>();
        assertEquals(files, parser.getRelevantFiles("testing-empty"));
    }

    @Test
    public void getRelevantFilesErrorThrown() throws Exception {
        when(clientMock.sendGet("https://www.vulncode-db.com/api/v1/testing-error")).thenReturn(errorJSON);
        var files = new ArrayList<String>();
        assertEquals(files, parser.getRelevantFiles("testing-error"));
    }

    @Test
    public void injectCpeInfoTest() {
        Vulnerability vulnerability = new Vulnerability("TEST");
        String cpeExample = "cpe:2.3:a:oracle:mysql:5.5.0:*:*:*:*:*:*:*";
        Vulnerability.Cpe23Uri cpeUri = new Vulnerability.Cpe23Uri("oracle", "mysql", "5.5.0");
        parser.injectCpeInfo(vulnerability, cpeExample);
        assertEquals(vulnerability.getCpe23Uris().get(0), cpeUri);
    }

    @Test
    public void parseVulnerabilities() {
        File path_to_zip = new File("./src/test/resources/test.json.gz");
        try {
            // Grab two items from the testing gzip for testing
            List<DefCveItem> cve = parser.parseCVEZip(path_to_zip).subList(0, 2);
            List<Vulnerability> vulnerabilities = new ArrayList<>();
            vulnerabilities.add(new Vulnerability("CVE-1999-0001"));
            vulnerabilities.add(new Vulnerability("CVE-1999-0002"));
            assertEquals(parser.parseVulnerability(cve.get(0)).getId(), vulnerabilities.get(0).getId());
            assertEquals(parser.parseVulnerability(cve.get(1)).getId(), vulnerabilities.get(1).getId());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public String readFile(String filePath) throws IOException {
        File file = new File(filePath);
        return FileUtils.readFileToString(file, StandardCharsets.UTF_8);
    }

    @Test
    public void parsingCommitsFromMongo() throws IOException {
        // Setup mocks to test the response
        String patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2013-01-14T03:59:38Z");
        String jsonCommit = readFile("./src/test/resources/commit.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        // Call parse Commit method
        parser.parseCommit(v, patchLink);

        // Verify Hunks in the commit
        List<Vulnerability.Hunk> hunks = new ArrayList<>();
        Vulnerability.Hunk oneHunk = new Vulnerability.Hunk(1968, "2014-01-14T03:59:38Z");
        hunks.add(oneHunk);

        Vulnerability.File vulnerable_file = new Vulnerability.File("Lib/test/test_socket.py", hunks, "2014-01-14T03:59:38Z");

        assertEquals(v.getVulnerable_files().size(), 4);
        List<String> filenames = v.getVulnerable_files().stream().map(Vulnerability.File::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingCommitsFromGithubAPI() throws Exception {
        String patchLink = "https://github.com/python/cpython/commit/fbf648ebba32bbc5aa571a4b09e2062a65fd2492";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2013-01-14T03:59:38Z");
        String jsonCommit = readFile("./src/test/resources/commit.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Call parse Commit method
        parser.parseCommit(v, patchLink);

        // Verify Hunks in the commit
        List<Vulnerability.Hunk> hunks = new ArrayList<>();
        Vulnerability.Hunk oneHunk = new Vulnerability.Hunk(1968, "2014-01-14T03:59:38Z");
        hunks.add(oneHunk);

        Vulnerability.File vulnerable_file = new Vulnerability.File("Lib/test/test_socket.py", hunks, "2014-01-14T03:59:38Z");

        assertEquals(v.getVulnerable_files().size(), 4);
        List<String> filenames = v.getVulnerable_files().stream().map(Vulnerability.File::getFileName).collect(Collectors.toList());
        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGHTorrent() throws IOException {
        // Setup mocks to test the response
        String prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2012-08-08T09:26:41Z");
        String jsonCommit = readFile("./src/test/resources/pr.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonCommit);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/pr_commit.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        parser.parsePullRequest(v, prLink);

        // Verify Hunks in the commit
        List<Vulnerability.Hunk> hunks = new ArrayList<>();
        Vulnerability.Hunk oneHunk = new Vulnerability.Hunk(49, "2012-09-08T09:26:41Z");
        hunks.add(oneHunk);

        Vulnerability.File vulnerable_file = new Vulnerability.File(
                "lib/omniauth/strategies/oauth2.rb",
                hunks, "2012-09-08T09:26:41Z");

        assertEquals(v.getVulnerable_files().size(), 1);
        List<String> filenames = v.getVulnerable_files().stream()
                .map(Vulnerability.File::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingPullRequestsGithub() throws Exception {
        // Setup mocks to test the response
        String prLink = "https://github.com/omniauth/omniauth-oauth2/pull/25";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2012-08-08T09:26:41Z");
        String jsonCommit = readFile("./src/test/resources/pr.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonCommit);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/pr_commit.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        parser.parsePullRequest(v, prLink);

        // Verify Hunks in the commit
        List<Vulnerability.Hunk> hunks = new ArrayList<>();
        Vulnerability.Hunk oneHunk = new Vulnerability.Hunk(49, "2012-09-08T09:26:41Z");
        hunks.add(oneHunk);

        Vulnerability.File vulnerable_file = new Vulnerability.File(
                "lib/omniauth/strategies/oauth2.rb",
                hunks, "2012-09-08T09:26:41Z");

        assertEquals(v.getVulnerable_files().size(), 1);
        List<String> filenames = v.getVulnerable_files().stream()
                .map(Vulnerability.File::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGHTorrent() throws Exception {
        // Setup mocks to test the response
        String issueLink = "https://github.com/python/cpython/pull/32";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2015-04-08T09:26:41Z");
        String jsonIssue = readFile("./src/test/resources/issue.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(jsonIssue);

        // Mock pull request behaviour
        String jsonPullRequest = readFile("./src/test/resources/pr_issue.txt");

        FindIterable mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        Document mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/commit_issue.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        parser.parseIssues(v, issueLink);

        // Verify Hunks in the commit
        List<Vulnerability.Hunk> hunks = new ArrayList<>();
        Vulnerability.Hunk oneHunk = new Vulnerability.Hunk(13, "2017-02-16T02:00:32Z");
        hunks.add(oneHunk);

        Vulnerability.File vulnerable_file = new Vulnerability.File(
                "Lib/importlib/abc.py",
                hunks, "2017-02-16T02:00:32Z");

        assertEquals(v.getVulnerable_files().size(), 5);
        List<String> filenames = v.getVulnerable_files().stream()
                .map(Vulnerability.File::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }

    @Test
    public void parsingIssuesGithub() throws Exception {
        // Setup mocks to test the response
        String issueLink = "https://github.com/python/cpython/pull/32";
        Vulnerability v = new Vulnerability("CVE-TEST-ID");
        v.setPublishedDate("2015-04-08T09:26:41Z");
        String jsonIssue = readFile("./src/test/resources/issue.txt");

        FindIterable mockIterable = Mockito.mock(FindIterable.class);
        when(issuesMock.find((Bson) Mockito.any())).thenReturn(mockIterable);
        Document mockDocument = Mockito.mock(Document.class);
        when(mockIterable.first()).thenReturn(mockDocument);
        when(mockDocument.toJson()).thenReturn(null);

        when(clientMock.sendGet(Mockito.any())).thenReturn(jsonIssue);

        // Mock pull request behaviour
        String jsonPullRequest = readFile("./src/test/resources/pr_issue.txt");

        FindIterable mockIterablePR = Mockito.mock(FindIterable.class);
        when(prsMock.find((Bson) Mockito.any())).thenReturn(mockIterablePR);
        Document mockDocumentPR = Mockito.mock(Document.class);
        when(mockIterablePR.first()).thenReturn(mockDocumentPR);
        when(mockDocumentPR.toJson()).thenReturn(jsonPullRequest);

        // Mock commit behaviour
        String jsonMergeCommit = readFile("./src/test/resources/commit_issue.txt");

        FindIterable mockIterableMergeCommit = Mockito.mock(FindIterable.class);
        when(commitsMock.find(eq("sha", Mockito.any()))).thenReturn(mockIterableMergeCommit);
        Document mockDocumentMergeCommit = Mockito.mock(Document.class);
        when(mockIterableMergeCommit.first()).thenReturn(mockDocumentMergeCommit);
        when(mockDocumentMergeCommit.toJson()).thenReturn(jsonMergeCommit);

        // Call parse Commit method
        parser.parseIssues(v, issueLink);

        // Verify Hunks in the commit
        List<Vulnerability.Hunk> hunks = new ArrayList<>();
        Vulnerability.Hunk oneHunk = new Vulnerability.Hunk(13, "2017-02-16T02:00:32Z");
        hunks.add(oneHunk);

        Vulnerability.File vulnerable_file = new Vulnerability.File(
                "Lib/importlib/abc.py",
                hunks, "2017-02-16T02:00:32Z");

        assertEquals(v.getVulnerable_files().size(), 5);
        List<String> filenames = v.getVulnerable_files().stream()
                .map(Vulnerability.File::getFileName).collect(Collectors.toList());

        assertTrue(filenames.contains(vulnerable_file.getFileName()));
    }
}

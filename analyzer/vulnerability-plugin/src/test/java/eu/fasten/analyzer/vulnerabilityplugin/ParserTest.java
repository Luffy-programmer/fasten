package eu.fasten.analyzer.vulnerabilityplugin;

import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import eu.fasten.analyzer.vulnerabilityplugin.utils.JavaHttpClient;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Parser;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import org.bson.Document;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.owasp.dependencycheck.data.nvd.json.DefCveItem;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

public class ParserTest {

    // Inject Java Http Client to test
    JavaHttpClient clientMock = Mockito.mock(JavaHttpClient.class);

    // Inject mock database in order to test
    MongoDatabase dbMock = Mockito.mock(MongoDatabase.class);
    MongoCollection<Document> commitsMock = Mockito.mock(MongoCollection.class);
    MongoCollection<Document> prsMock = Mockito.mock(MongoCollection.class);
    private Parser parser;

    static final String validJSON = "{" +
            "\"comment\":\"Testing\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"Retrieve Relevant files\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[]," +
            "\"master_commit\":{" +
                "\"commit_hash\":\"hash\"," +
                "\"commit_link\":\"https://github.com/generic_commit\"," +
                "\"relevant_files\":[\"./src/index.c\",\"./src/mock.c\"]," +
                "\"repo_name\":\"test\"," +
                "\"repo_owner\":\"random\"," +
                "\"repo_url\":\"" +
            "\"}," +
            "\"products\":[]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String emptyMasterCommit = "{" +
            "\"comment\":\"Testing JSON body valid\"," +
            "\"cve_id\":\"CVE-TEST-TEST\"," +
            "\"cwes\":[]," +
            "\"description\":\"n/a\"," +
            "\"exploit_exists\":false," +
            "\"has_annotations\":true," +
            "\"is_processed\":true," +
            "\"langs\":[\"ANY\"]," +
            "\"master_commit\":{}," +
            "\"products\":[{\"product\":\"python\",\"vendor\":\"python\"}]," +
            "\"references\":[]," +
            "\"score\":null" +
            "}";

    final String errorJSON = "{\"code\":404,\"error\":\"Not found\"}";

    @BeforeEach
    public void setup() {
        when(dbMock.getCollection("commits")).thenReturn(commitsMock);
        when(dbMock.getCollection("pull_requests")).thenReturn(prsMock);
        parser = new Parser(dbMock, clientMock);
    }

    @Test
    public void getRelevantFilesValidJson() throws Exception {
        when(clientMock.sendGet("https://www.vulncode-db.com/api/v1/testing-valid")).thenReturn(validJSON);
        List<String> files = new ArrayList<String>();
        files.add("./src/index.c"); files.add("./src/mock.c");
        assertEquals(files, parser.getRelevantFiles("testing-valid"));
    }

    @Test
    public void getRelevantFilesEmptyJson() throws Exception {
        when(clientMock.sendGet("https://www.vulncode-db.com/api/v1/testing-empty")).thenReturn(emptyMasterCommit);
        var files = new ArrayList<String>();
        assertEquals(files, parser.getRelevantFiles("testing-empty"));
    }

    @Test
    public void getRelevantFilesErrorThrown() throws Exception {
        when(clientMock.sendGet("https://www.vulncode-db.com/api/v1/testing-error")).thenReturn(errorJSON);
        var files = new ArrayList<String>();
        assertEquals(files, parser.getRelevantFiles("testing-error"));
    }

    @Test
    public void injectCpeInfoTest() {
        Vulnerability vulnerability = new Vulnerability("TEST");
        String cpeExample = "cpe:2.3:a:oracle:mysql:5.5.0:*:*:*:*:*:*:*";
        Vulnerability.Cpe23Uri cpeUri = new Vulnerability.Cpe23Uri("oracle", "mysql", "5.5.0");
        parser.injectCpeInfo(vulnerability, cpeExample);
        assertEquals(vulnerability.getCpe23Uris().get(0), cpeUri);
    }

    @Test
    public void parseVulnerabilities() {
        File path_to_zip = new File("./src/test/resources/test.json.gz");
        try {
            // Grab two items from the testing gzip for testing
            List<DefCveItem> cve = parser.parseCVEZip(path_to_zip).subList(0, 2);
            List<Vulnerability> vulnerabilities = new ArrayList<>();
            vulnerabilities.add(new Vulnerability("CVE-1999-0001"));
            vulnerabilities.add(new Vulnerability("CVE-1999-0002"));
            assertEquals(parser.parseVulnerability(cve.get(0)).getId(), vulnerabilities.get(0).getId());
            assertEquals(parser.parseVulnerability(cve.get(1)).getId(), vulnerabilities.get(1).getId());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

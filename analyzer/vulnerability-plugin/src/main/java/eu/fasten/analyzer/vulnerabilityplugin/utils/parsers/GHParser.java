/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.utils.parsers;

import com.fasterxml.jackson.databind.ObjectMapper;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.analyzer.vulnerabilityplugin.utils.connections.JavaHttpClient;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.JSONHandler;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.VersionRanger;

import java.util.HashMap;
import java.util.List;

public class GHParser {

    JavaHttpClient client;
    ObjectMapper objectMapper;
    VersionRanger versionRanger;
    String token;
    String cursor;
    String pathToVersions = "./analyzer/vulnerability-plugin/src/main/resources/trackers/package_versions.json";

    public GHParser(JavaHttpClient client, String token) {
        this.cursor = null;
        this.token = token;
        this.client = client;
        this.versionRanger = new VersionRanger(client, pathToVersions);
        this.objectMapper = new ObjectMapper();
    }

    public VersionRanger getVersionRanger() {
        return versionRanger;
    }

    /**
     * Builds a query for GraphQL API setting a cursor if supplied
     * @param cursor - cursor provided by GH API
     * @return raw response from GH API
     */
    public String buildQuery(String cursor) {
        String secondLine;
        if (cursor != null) {
            secondLine = "  securityAdvisories(first: 100, after: \""+ cursor +"\") {\n";
        } else {
            secondLine = "  securityAdvisories(first: 100) {\n";
        }
        return "query {\n" + secondLine +
                "    nodes {\n" +
                "      description\n" +
                "      identifiers {\n" +
                "        type\n" +
                "        value\n" +
                "      }\n" +
                "      severity\n" +
                "      references {\n" +
                "        url\n" +
                "      }\n" +
                "      vulnerabilities(first: 1) {\n" +
                "        nodes {\n" +
                "          package {\n" +
                "            ecosystem\n" +
                "            name\n" +
                "          }\n" +
                "          vulnerableVersionRange\n" +
                "        }\n" +
                "      }\n" +
                "    }\n" +
                "    pageInfo {\n" +
                "      endCursor\n" +
                "      hasNextPage\n" +
                "    }\n" +
                "  }\n" +
                "}";
    }

    /**
     * Parses the response from GH API and injects the information in the list of dependencies
     * @param response from GH that includes enough information to build a Vulnerability Object
     * @param vulnerabilities hashmap to inject vulnerabilities into
     */
    public void parseGHResponse(JSONHandler.GHResponse response, HashMap<String, Vulnerability> vulnerabilities) {
        for (JSONHandler.GHAdvisory advisory : response.getData().getSecurityAdvisories().getNodes()) {
            Vulnerability v = new Vulnerability(advisory.getAdvisoryId());
            v.setSeverity(advisory.getSeverity());
            v.setDescription(advisory.getDescription());
            for (JSONHandler.GHReference ref : advisory.getReferences()) {
                v.addReference(ref.getUrl());
            }
            for (JSONHandler.GHNodes node : advisory.getVulnerabilities().getNodes()) {
                String ecosystem = node.ghPackage.ecosystem;
                String pgkIdentifier = null;
                if (ecosystem.equals("PIP")) {
                    pgkIdentifier = "/pypi/" + node.getGhPackage().name;
                }
                if (ecosystem.equals("MAVEN")) {
                    String[] coordinates = node.getGhPackage().getName().split(":");
                    if (coordinates.length > 1) {
                        pgkIdentifier = "/maven/" + coordinates[0] + "/" + coordinates[1];
                    } else {
                        String[] splits = coordinates[0].split("\\.");
                        pgkIdentifier = "/maven/" + coordinates[0] + "/" + splits[splits.length - 1];
                    }
                }
                if (pgkIdentifier != null) {
                    List<String> allVersions = versionRanger.getVersions(pgkIdentifier);
                    if (allVersions != null) {
                        List<String> vulnerableVersions = versionRanger.getVulnerableVersionsJSON(node.vulnerableVersionRange.split(", "), allVersions);
                        for (String version : vulnerableVersions) {
                            v.addPurl(pgkIdentifier + "@" + version);
                        }
                    }
                }
            }
            // Add the vulnerability to the Hash Map
            vulnerabilities.put(v.getId(), v);
        }
    }

    /**
     * Parser the GH Advisories listings and later merges with NVD Data
     * @return List of Vulnerabilities
     */
    public HashMap<String, Vulnerability> getVulnerabilitiesFromGH() {
        HashMap<String, Vulnerability> vulnerabilities = new HashMap<>();
        JSONHandler.GHResponse response = null;

        // Step 1: Make the first request without any cursor
        String queryWithoutCursor = buildQuery(this.cursor);
        var values = new HashMap<String, String>();
        values.put("query", queryWithoutCursor);
        try {
            String result = client.sendPost("https://api.github.com/graphql", token, values);
            response = objectMapper.readValue(result, JSONHandler.GHResponse.class);
            parseGHResponse(response, vulnerabilities);
        } catch (Exception e) {
            e.printStackTrace();
        }

        // Step 2: Integrate the request with the cursor and parse the data
        while (response.getData().getSecurityAdvisories().getPageInfo().hasNextPage) {
            this.cursor = response.getData().getSecurityAdvisories().getPageInfo().endCursor;
            String queryWithCursor = buildQuery(this.cursor);
            values.put("query", queryWithCursor);
            try {
                String result = client.sendPost("https://api.github.com/graphql", token, values);
                response = objectMapper.readValue(result, JSONHandler.GHResponse.class);
                parseGHResponse(response, vulnerabilities);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return vulnerabilities;
    }

    /**
     * This method retrieves updates once a day from GH.
     * Since the cursor is a field of the class, it is resilient.
     * @return hashmap of vulnerabilities
     */
    public HashMap<String, Vulnerability> getGHUpdates() {
        return getVulnerabilitiesFromGH();
    }
}

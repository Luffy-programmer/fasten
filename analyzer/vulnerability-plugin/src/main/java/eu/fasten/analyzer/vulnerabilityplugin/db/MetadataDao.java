/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.db;

import com.github.t9t.jooq.json.JsonDSL;
import com.github.t9t.jooq.json.JsonbDSL;
import com.google.gson.JsonObject;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.PURLPackage;
import eu.fasten.core.data.metadatadb.codegen.Keys;
import eu.fasten.core.data.metadatadb.codegen.tables.*;
import eu.fasten.core.data.metadatadb.codegen.tables.records.*;
import eu.fasten.core.merge.CallGraphMerger;
import eu.fasten.server.connectors.PostgresConnector;
import netscape.javascript.JSObject;
import org.jooq.*;
import org.json.JSONObject;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class MetadataDao {
    private DSLContext context;

    public MetadataDao(DSLContext context) {
        this.context = context;
    }

    public DSLContext getContext() {
        return this.context;
    }

    public void setContext(DSLContext context) {
        this.context = context;
    }

    /**
     * Given a vulnerability, it adds the information at the Package Version level detail
     * @param v
     */
    public void insertPackageLevelDetail(Vulnerability v) {
        // Step 1: Find ids of packages that need to contain the information
        List<Long> packageVersionsIds = findVulnerablePackageVersion(v);
        // Step 2: For each package version id, update the metadata with the new information
        for (Long packageId : packageVersionsIds) {
            updatePackageVersionMetadata(packageId, new JSONObject(v.toJson()));
        }
    }

    public List<Long> findVulnerablePackageVersion(Vulnerability v) {
        return null;
    }

    public void updatePackageVersionMetadata(Long id, JSONObject metadata) {
        var metadataJsonb = metadata != null ? JSONB.valueOf(metadata.toString()) : null;
        // Step 1: Get the JSON from old one
        PackageVersionsRecord res = (PackageVersionsRecord) context.select().from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(id)).fetchOne();
        JSONObject obj1 = new JSONObject(res.getMetadata().data());
        JSONObject obj2 = new JSONObject(metadataJsonb.data());

        obj1.put("vulnerabilities", obj2);
        // Step 2: Append JSON to old one
        // Step 3: Update the old JSON with the new one
        var objJSONb = obj1 != null ? JSONB.valueOf(obj1.toString()) : null;
        context.update(PackageVersions.PACKAGE_VERSIONS)
                .set(PackageVersions.PACKAGE_VERSIONS.METADATA, objJSONb)
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(1L)).execute();
    }

    /**
     * Method to inject the information contained in a Vulnerability Object.
     * The following explains the logic used to insert the information:
     * First, the information at the package level is injected. This is done by looping through
     * all the purls contained in the object. We store the IDs of the package_version row.
     *
     * Second, we try to find the callables responsible.
     * @param v
     */
    public void injectVulnerabilityIntoDB(Vulnerability v) {
        // Inject all the info at the package-level and store packageVersionsId
        HashMap<String, Long> pkgIds = new HashMap<>();
        String lastVersionPurl = null;

        for (String purl : v.getPurls()) {
            Long pkgId = getPackageVersionId(purl);
            if (pkgId > 0) {
                injectInfoAtPackageLevelDetail(v);
                pkgIds.put(purl, pkgId);
            }
            // Compare to get the last version of purl
            if (lastVersionPurl != null) {
                if (purl.compareTo(lastVersionPurl) > 0) {
                    lastVersionPurl = purl;
                }
            } else {
                lastVersionPurl = purl;
            }
        }

        // For each of the files changed in the patches of the vulnerability
        // Find the FastenURI of the callable for the "first" purl
        // Propagate the same information at the callables for the other purls.
        for (Vulnerability.File file : v.getVulnerableFiles()) {
            // Get the fasten_uri from the most recent vulnerable versions
            // TODO: It could be a list of fasten_uris, not only one
            List<String> fastenURIs = injectCallablesFromFile(file, pkgIds.get(lastVersionPurl));
            // Propagate the same to the earlier versions changing the fastenURI
        }
    }

    /**
     * Given a file and a package version id, looks for each hunk in the file.
     * The fasten_uri of each callable that is found at the linenumber indicated in the hunk
     * is then stored and returned.
     * @param file
     * @param pkgVersionId
     * @return
     */
    private List<String> injectCallablesFromFile(Vulnerability.File file, Long pkgVersionId) {
        List<String> fastenURIs = new ArrayList<>();

        // Get the fileID
        Long fileId = getFileId(pkgVersionId, file.getFileName());
        if (fileId < 0) return fastenURIs;

        Long moduleId = getModuleId(fileId);

        // Get callables information for the file
        // We need to know the fasten_uri + first + last
        List<CallableHolder> callableHolders = getCallablesInformation(moduleId);

        // For each hunk, get the line number and look in the callables table
        for (Vulnerability.Hunk hunk : file.getHunks()) {
//            Long callableId = getCallableId(fileId, hunk.getLineNumber());
        }

        return null;
    }

    /**
     * Retrieves the callables information to use them later.
     * @param moduleId - Long ID of the file where the callable was changed.
     * @return Long ID of the callable (-1L if it cannot find it)
     */
    private List<CallableHolder> getCallablesInformation(Long moduleId) {
        List<CallableHolder> calls = new ArrayList<>();
        // Get all the records with the moduleId given
         Result<Record> crs = context.select()
                 .from(Callables.CALLABLES)
                 .where(Callables.CALLABLES.MODULE_ID.equal(moduleId))
                 .fetch();
         for (Record cr : crs) {
             Long callableId = (Long) cr.get(0);
             String fastenUri = (String) cr.get(2);
             JSONB metadata = (JSONB) cr.get(5);
             JSONObject obj = new JSONObject(metadata.data());
             int first = (int) obj.get("first");
             int last = (int) obj.get("last");

             // Create callable object and store it
             CallableHolder ch = new CallableHolder(callableId,
                     fastenUri, first, last);

             calls.add(ch);
         }
        return calls;
    }

    private void injectInfoAtPackageLevelDetail(Vulnerability vulnerability) {
    }

    /**
     * Retrieves the package_version_id given the purl of the package version.
     * @param purl - follows purl specifications
     * @return negative if it cannot be found
     */
    public Long getPackageVersionId(String purl) {
        // Check if the package exists
        // Step 0: Brake down purl to get the information you need
        PURLPackage packageObject = PURLPackage.getObjectFromPurl(purl);

        if (packageObject.getType().equals("mvn")) {
            // Step 1: Find package ID of the package with specific name
            String mvnCoordinate = packageObject.getNamespace() + ":" + packageObject.getName();
            PackagesRecord packageRecord = (PackagesRecord) context.select()
                    .from(Packages.PACKAGES)
                    .where(Packages.PACKAGES.PACKAGE_NAME.equal(mvnCoordinate))
                    .and(Packages.PACKAGES.FORGE.equal(packageObject.getType()))
                    .fetchOne();

            if (packageRecord != null) {

                // Find the package version record
                PackageVersionsRecord pgkVersionRecord = (PackageVersionsRecord) context.select()
                        .from(PackageVersions.PACKAGE_VERSIONS)
                        .where(PackageVersions.PACKAGE_VERSIONS.PACKAGE_ID.equal(packageRecord.component1()))
                        .and(PackageVersions.PACKAGE_VERSIONS.VERSION.equal(packageObject.getVersion()))
                        .fetchOne();

                if (pgkVersionRecord != null) {
                    return pgkVersionRecord.getId();
                }
            }
        }
        if (packageObject.getType().equals("PyPI")) {
            //TODO: Implement checks for Python packages to find the package
        }
        if (packageObject.getType().equals("debian")) {
            //TODO: Implement checks for Debian packages to find them in the DB
        }
        return -1L;
    }

    /**
     * Retrieve the fileId of the file that was patched.
     * @param packageVersionId - Long pkg version ID
     * @param filepath - path to the file
     * @return -1 if the file cannot be found
     */
    public Long getFileId(Long packageVersionId, String filepath) {
        // For the demo, just cut out the filename, without the path
        var splits = filepath.split("/");
        var filename = splits[splits.length];

        FilesRecord fr = (FilesRecord) context.select()
                .where(Files.FILES.PACKAGE_VERSION_ID.equal(packageVersionId))
                .and(Files.FILES.PATH.equal(filename))
                .fetchOne();

        if (fr != null) {
            return fr.getId();
        } else {
            return -1L;
        }
    }

    /**
     * Gets the moduleId that corresponds to the file.
     * @param fileId - Long fileId
     * @return -1 if the module cannot be found
     */
    public Long getModuleId(Long fileId) {
        ModuleContentsRecord mcr = (ModuleContentsRecord) context.select()
                .where(ModuleContents.MODULE_CONTENTS.FILE_ID.equal(fileId))
                .fetchOne();

        if (mcr != null) {
            return mcr.getFileId();
        } else {
            return -1L;
        }
    }

    /**
     * In order to connect to Postgres, an env variable need to be set when
     * running the Plugin
     * @param args
     * @throws SQLException
     */
    public static void main(String[] args) throws SQLException {
        var dbUrl = "jdbc:postgresql://localhost:5432/vuln_plugin_dom4j";
        var dbUser = "postgres";
        var context = PostgresConnector.getDSLContext(dbUrl, dbUser);

        MetadataDao md = new MetadataDao(context);
        List<CallableHolder> chs = md.getCallablesInformation(3L);

        for (CallableHolder ch : chs) {
            System.out.println(ch.getFastenURI());
        }
    }
}

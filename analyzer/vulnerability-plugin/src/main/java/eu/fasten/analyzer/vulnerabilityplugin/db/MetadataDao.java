/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.db;

import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.PURLPackage;
import eu.fasten.core.data.metadatadb.codegen.tables.*;
import eu.fasten.core.data.metadatadb.codegen.tables.records.*;
import eu.fasten.server.connectors.PostgresConnector;
import org.jooq.*;
import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class MetadataDao {
    private DSLContext context;
    private final Logger logger = LoggerFactory.getLogger(MetadataDao.class.getName());

    public MetadataDao(DSLContext context) {
        this.context = context;
    }

    public DSLContext getContext() {
        return this.context;
    }

    public void setContext(DSLContext context) {
        this.context = context;
    }

//    /**
//     * Given a vulnerability, it adds the information at the Package Version level detail
//     * @param v
//     */
//    public void insertPackageLevelDetail(Vulnerability v) {
//        // Step 1: Find ids of packages that need to contain the information
//        List<Long> packageVersionsIds = findVulnerablePackageVersion(v);
//        // Step 2: For each package version id, update the metadata with the new information
//        for (Long packageId : packageVersionsIds) {
//            updatePackageVersionMetadata(packageId, new JSONObject(v.toJson()));
//        }
//    }
//
//    public List<Long> findVulnerablePackageVersion(Vulnerability v) {
//        return null;
//    }
//
//    public void updatePackageVersionMetadata(Long id, JSONObject metadata) {
//        var metadataJsonb = metadata != null ? JSONB.valueOf(metadata.toString()) : null;
//        // Step 1: Get the JSON from old one
//        PackageVersionsRecord res = (PackageVersionsRecord) context.select()
//                .from(PackageVersions.PACKAGE_VERSIONS)
//                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(id))
//                .fetchOne();
//        JSONObject obj1 = new JSONObject(res.getMetadata().data());
//        JSONObject obj2 = new JSONObject(metadataJsonb.data());
//
//        obj1.put("vulnerabilities", obj2);
//        // Step 2: Append JSON to old one
//        // Step 3: Update the old JSON with the new one
//        var objJSONb = obj1 != null ? JSONB.valueOf(obj1.toString()) : null;
//        context.update(PackageVersions.PACKAGE_VERSIONS)
//                .set(PackageVersions.PACKAGE_VERSIONS.METADATA, objJSONb)
//                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(1L)).execute();
//    }

    /**
     * Method to inject the information contained in a Vulnerability Object.
     * The following explains the logic used to insert the information:
     * First, the information at the package level is injected. This is done by looping through
     * all the purls contained in the object. We store the IDs of the package_version row.
     *
     * Second, we try to find the callables responsible.
     * @param v
     */
    public void injectVulnerabilityIntoDB(Vulnerability v) {
        logger.info("Injecting vulnerability " + v.getId() + " into the Database");
        // Inject all the info at the package-level and store packageVersionsId
        HashMap<String, Long> pkgIds = new HashMap<>();
        String lastVersionPurl = null;

        for (String purl : v.getPurls()) {
            Long pkgId = getPackageVersionId(purl);
            if (pkgId > 0) {
                injectInfoAtPackageLevelDetail(v, pkgId);
                pkgIds.put(purl, pkgId);

                // Compare to get the last version of purl
                if (lastVersionPurl != null) {
                    if (purl.compareTo(lastVersionPurl) > 0) {
                        lastVersionPurl = purl;
                    }
                } else {
                    lastVersionPurl = purl;
                }
            }
        }

        // For each of the files changed in the patches of the vulnerability
        // Find the FastenURI of the callable for the "first" purl
        // Propagate the same information at the callables for the other purls.
        if (lastVersionPurl != null) {
            for (Vulnerability.File file : v.getVulnerableFiles()) {
                logger.info("Searching for callables found in " + file.getFileName()
                        + " in purl:" + lastVersionPurl);
                // Get the fasten_uri from the most recent vulnerable versions
                List<String> fastenURIs = getFastenUrisForVulnerability(file, pkgIds.get(lastVersionPurl));
                // Propagate the same to the earlier versions changing the fastenURI
                logger.info("Found " + fastenURIs.size() + " fasten_uris to propagate in other versions");
                for (String uri : fastenURIs) {
                    // Get all the callables with the fasten_uri
                    List<Long> callableIds = getCallableIdsForFastenUri(uri);
                    // Inject the metadata in the callable row
                    for (Long id : callableIds) {
                        injectInfoAtCallableLevelDetail(v, id);
                    }
                }
            }
        }
    }

    /**
     * Finds all the callable ids with the given fasten_uri
     * @param fastenUri - String
     * @return - List of ids of the callables
     */
    private List<Long> getCallableIdsForFastenUri(String fastenUri) {
        List<Long> ids = new ArrayList<>();

        Result<Record> crs = context.select()
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.FASTEN_URI.equal(fastenUri))
                .fetch();

        for (Record cr : crs) {
            ids.add((Long) cr.get(0));
        }

        return ids;
    }

    /**
     * Given a file and a package version id, looks for each hunk in the file.
     * The fasten_uri of each callable that is found at the linenumber indicated in the hunk
     * is then stored and returned.
     * @param file - that contains hunks with the changes to the file
     * @param pkgVersionId - Long - ID of the package version
     * @return List of fastenURIs to
     */
    private List<String> getFastenUrisForVulnerability(Vulnerability.File file, Long pkgVersionId) {
        List<String> fastenURIs = new ArrayList<>();

        // Get the fileID
        Long fileId = getFileId(pkgVersionId, file.getFileName());
        if (fileId < 0) return fastenURIs;

        // There could be more moduleIds for the same file
        List<Long> moduleIds = getModuleIds(fileId);
        logger.info("Found " + moduleIds.size() + " modules corresponding to file with id " + fileId);

        for (Long moduleId : moduleIds) {
            // Get callables information for the file
            // We need to know the fasten_uri + first + last
            List<CallableHolder> callableHolders = getCallablesInformation(moduleId);

            // For each hunk, get the line number and look in the callables table
            for (Vulnerability.Hunk hunk : file.getHunks()) {
                // Find the callable
                CallableHolder callable = getCallableThatContainsLine(callableHolders, hunk.getLineNumber());
                if (callable != null) {
                    // Store fastenURI for later use
                    logger.info("Found vulnerable callable with fasten_uri: " + callable.getFastenURI());
                    fastenURIs.add(callable.getFastenURI());
                }
            }
        }

        return fastenURIs;
    }

    /**
     * Method to append vulnerabilities information in the metadata JSON.
     * @param v - Vulnerability object that holds the information
     * @param callableId - Long callable ID
     */
    private void injectInfoAtCallableLevelDetail(Vulnerability v, Long callableId) {
        logger.info("Updating metadata for callable with ID: " + callableId + " adding " + v.getId());
        // Create JSONObject of the information in the Vulnerability
        JSONObject vulnData = new JSONObject(v.toJson());
        var vulnJsonb = vulnData != null ? JSONB.valueOf(vulnData.toString()) : null;

        // Step 1: Get the metadata JSON in the DB
        CallablesRecord res = (CallablesRecord) context.select()
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.ID.equal(callableId)).fetchOne();

        JSONObject obj1 = new JSONObject(res.getMetadata().data());
        JSONObject obj2 = new JSONObject(vulnJsonb.data());

        JSONArray vulns;
        if (obj1.has("vulnerabilities")) {
            vulns = (JSONArray) obj1.get("vulnerabilities");
        } else {
            vulns = new JSONArray();
        }
        vulns.put(obj2);

        // Step 2: Append updates vulnerabilities to old JSON
        obj1.put("vulnerabilities", vulns);
        var objJSONb = obj1 != null ? JSONB.valueOf(obj1.toString()) : null;

        // Insert the new value in the DB
        context.update(Callables.CALLABLES)
                .set(Callables.CALLABLES.METADATA, objJSONb)
                .where(Callables.CALLABLES.ID.equal(callableId)).execute();
    }

    /**
     * Finds the callable that interests the specific line number we are looking at.
     * @param callableHolders - list of CallableHolders
     * @param lineNumber - Integer line number where the change was made
     * @return CallableHolder object
     */
    private CallableHolder getCallableThatContainsLine(List<CallableHolder> callableHolders, int lineNumber) {
        for (CallableHolder ch : callableHolders) {
            if (ch.getFirst() <= lineNumber && ch.getLast() >= lineNumber) {
                return ch;
            }
        }
        return null;
    }

    /**
     * Retrieves the callables information to use them later.
     * @param moduleId - Long ID of the file where the callable was changed.
     * @return Long ID of the callable (-1L if it cannot find it)
     */
    private List<CallableHolder> getCallablesInformation(Long moduleId) {
        List<CallableHolder> calls = new ArrayList<>();
        // Get all the records with the moduleId given
         Result<Record> crs = context.select()
                 .from(Callables.CALLABLES)
                 .where(Callables.CALLABLES.MODULE_ID.equal(moduleId))
                 .fetch();
         for (Record cr : crs) {
             Long callableId = (Long) cr.get(0);
             String fastenUri = (String) cr.get(2);
             JSONB metadata = (JSONB) cr.get(5);
             JSONObject obj = new JSONObject(metadata.data());
             int first = (int) obj.get("first");
             int last = (int) obj.get("last");

             // Create callable object and store it
             CallableHolder ch = new CallableHolder(callableId,
                     fastenUri, first, last);

             calls.add(ch);
         }
        return calls;
    }

    /**
     * Updating the metadata of the package versions injecting vulnerability information.
     * @param v - Vulnerability Object
     * @param pkgId - Long ID of the package version to inject
     */
    private void injectInfoAtPackageLevelDetail(Vulnerability v, Long pkgId) {
        logger.info("Updating metadata for package version with ID: " + pkgId + " adding " + v.getId());
        // Create JSONObject of the information in the Vulnerability
        JSONObject vulnData = new JSONObject(v.toJson());
        var vulnJsonb = vulnData != null ? JSONB.valueOf(vulnData.toString()) : null;

        // Step 1: Get the metadata JSON in the DB
        PackageVersionsRecord res = (PackageVersionsRecord) context.select()
                .from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgId)).fetchOne();

        JSONObject obj1;
        if (res.getMetadata() != null) {
            obj1 = new JSONObject(res.getMetadata().data());
        } else {
            obj1 = new JSONObject();
        }
        JSONObject obj2 = new JSONObject(vulnJsonb.data());

        JSONArray vulns;
        if (obj1.has("vulnerabilities")) {
            vulns = (JSONArray) obj1.get("vulnerabilities");
        } else {
            vulns = new JSONArray();
        }
        vulns.put(obj2);

        // Step 2: Append updates vulnerabilities to old JSON
        obj1.put("vulnerabilities", vulns);
        var objJSONb = obj1 != null ? JSONB.valueOf(obj1.toString()) : null;

        // Insert the new value in the DB
        context.update(PackageVersions.PACKAGE_VERSIONS)
                .set(PackageVersions.PACKAGE_VERSIONS.METADATA, objJSONb)
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgId)).execute();
    }

    /**
     * Retrieves the package_version_id given the purl of the package version.
     * @param purl - follows purl specifications
     * @return negative if it cannot be found
     */
    private Long getPackageVersionId(String purl) {
        logger.info("Looking for package_version_id of " + purl);
        // Check if the package exists
        // Step 0: Brake down purl to get the information you need
        PURLPackage packageObject = PURLPackage.getObjectFromPurl(purl);

        if (packageObject.getType().equals("mvn")) {
            // Step 1: Find package ID of the package with specific name
            String mvnCoordinate = packageObject.getNamespace() + ":" + packageObject.getName();
            PackagesRecord packageRecord = (PackagesRecord) context.select()
                    .from(Packages.PACKAGES)
                    .where(Packages.PACKAGES.PACKAGE_NAME.equal(mvnCoordinate))
                    .and(Packages.PACKAGES.FORGE.equal(packageObject.getType()))
                    .fetchOne();

            if (packageRecord != null) {

                // Find the package version record
                PackageVersionsRecord pgkVersionRecord = (PackageVersionsRecord) context.select()
                        .from(PackageVersions.PACKAGE_VERSIONS)
                        .where(PackageVersions.PACKAGE_VERSIONS.PACKAGE_ID.equal(packageRecord.component1()))
                        .and(PackageVersions.PACKAGE_VERSIONS.VERSION.equal(packageObject.getVersion()))
                        .fetchOne();

                if (pgkVersionRecord != null) {
                    return pgkVersionRecord.getId();
                }
            }
        }
        if (packageObject.getType().equals("PyPI")) {
            //TODO: Implement checks for Python packages to find the package
        }
        if (packageObject.getType().equals("debian")) {
            //TODO: Implement checks for Debian packages to find them in the DB
        }
        return -1L;
    }

    /**
     * Retrieve the fileId of the file that was patched.
     * @param packageVersionId - Long pkg version ID
     * @param filepath - path to the file
     * @return -1 if the file cannot be found
     */
    public Long getFileId(Long packageVersionId, String filepath) {
        // For the demo, just cut out the filename, without the path
        var splits = filepath.split("/");
        var filename = splits[splits.length - 1];

        FilesRecord fr = (FilesRecord) context.select()
                .from(Files.FILES)
                .where(Files.FILES.PACKAGE_VERSION_ID.equal(packageVersionId))
                .and(Files.FILES.PATH.equal(filename))
                .fetchOne();

        if (fr != null) {
            return fr.getId();
        } else {
            return -1L;
        }
    }

    /**
     * Gets the moduleId that corresponds to the file.
     * @param fileId - Long fileId
     * @return list of module Ids
     */
    public List<Long> getModuleIds(Long fileId) {
        List<Long> moduleIds = new ArrayList<>();
        Result<Record> mcr = context.select()
                .from(ModuleContents.MODULE_CONTENTS)
                .where(ModuleContents.MODULE_CONTENTS.FILE_ID.equal(fileId))
                .fetch();

        for (Record record : mcr) {
            moduleIds.add((Long) record.get(0));
        }

        return moduleIds;
    }
}

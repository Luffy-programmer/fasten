/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.utils;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.json.JSONArray;
import org.json.JSONObject;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;


public class CVEMapper {

    // Vulnerability-ID --> PURL of affected packages
    HashMap<String, HashSet<String>> dictionary;
    // TODO: Enrich with more information of commits --> GOLD
    HashMap<String, HashSet<String>> additionalLinks;
    JavaHttpClient client;
    VersionRanger versionRanger;

    /**
     * Constructor to build a CPEFinder.
     * The same client is injected in both CPEFinder and the VersionRanger.
     * This will help with Mocking when testing later.
     * @param client - JavaHttpClient
     */
    public CVEMapper(JavaHttpClient client) {
        this.dictionary = new HashMap<>();
        this.versionRanger = new VersionRanger(client);
        this.client = client;
    }

    public void injectDebianOVAL() {
        // TODO: Parse Debian OVAL
        // Find more info here: https://www.debian.org/security/oval/
    }

    /**
     * Injects information in the dictionary from the dataset provided by pyupio on Github.
     * Find more information here: https://github.com/pyupio/safety-db
     * The JSON Feed is updated monthly.
     */
    public void injectSafetyDB() {
        try {
            String insecureJson = client.sendGet("https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json");
            // Save the file to later compare
            FileWriter file = new FileWriter("./analyzer/vulnerability-plugin/src/main/resources/datasets/insecure_full.json");
            file.write(insecureJson);

            JSONObject jsonObject = new JSONObject(insecureJson.trim());
            Iterator<String> keys = jsonObject.keys();

            while(keys.hasNext()) {
                String key = keys.next();
                JSONArray listVulns = (JSONArray) jsonObject.get(key);
                Iterator<Object> vulnIterator = listVulns.iterator();
                while (vulnIterator.hasNext()) {
                    JSONObject vulnObject = (JSONObject) vulnIterator.next();
                    var cveIds = vulnObject.get("cve");
                    if (!cveIds.toString().equals("null")) {
                        // There are multiple CVE-IDs
                        if (cveIds.toString().contains(",")) {
                            String[] cves = cveIds.toString().split(",\\s?");
                            for (String cve : cves) {
                                injectInfoHelper(key, cve, vulnObject);
                            }
                        } else {
                            // There is only one CVE-ID
                            var cveId = cveIds;
                            injectInfoHelper(key, cveId.toString(), vulnObject);
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Takes a CVE-ID and a JSONObject from safetydb specification and injects information in the dictionary.
     * @param packageName - name of the package to retrieve vulnerable versions from.
     * @param cve - id of the cve to store in the dictionary.
     * @param vulnObject - JSON Object containing the information related to the package and its vulnerabilities.
     */
    private void injectInfoHelper(String packageName, String cve, JSONObject vulnObject) {
        List<String> versionsPgk = versionRanger.getVersions("/pypi/" + packageName);
        String[] ranges = vulnObject.get("v").toString().split(",");
        if (versionsPgk != null) {
            List<String> vulnerableVersions = versionRanger.getVulnerableVersionsJSON(ranges, versionsPgk);
            HashSet<String> purls = new HashSet<>();
            for (String vulnerableVersion : vulnerableVersions) {
                purls.add("/pypi/" + packageName + "@" + vulnerableVersion);
            }
            dictionary.put(cve, purls);
        }
    }

    /**
     * This method can pull information from https://github.com/fabric8-analytics/cvedb
     * and https://github.com/victims/victims-cve-db
     * The bot that creates PRs is by far the best mapper between NVD and package coordinates.
     * Unfortunately, the repo is not very maintained and that means PRs are not merged so often.
     * Example of inputs:
     * https://github.com/victims/victims-cve-db.git
     * https://github.com/fabric8-analytics/cvedb.git
     */
    public void injectYAMLSource(String repoUrl) {
        String repoName = repoUrl.split("/")[4].split("\\.")[0];
        String cloneDirectoryPath = "./analyzer/vulnerability-plugin/src/main/resources/datasets/" + repoName;
        File checkDirAlreadyExists = new File(cloneDirectoryPath);
        if (checkDirAlreadyExists.exists()) {
            try {
                FileUtils.deleteDirectory(new File(cloneDirectoryPath));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try {
            // Step 1: Clone the repo
            Git git = Git.cloneRepository()
                    .setURI(repoUrl)
                    .setDirectory(Paths.get(cloneDirectoryPath).toFile())
                    .call();
            // Step 2: Parse the information in the repo
            // Parse Java Database
            Yaml javaYaml = new Yaml(new Constructor(YAMLHandler.JavaVulnMapper.class));
            String[] years = new File(cloneDirectoryPath + "/database/java").list();
            for (String year : years) {
                try {
                    String pathToYearDir = cloneDirectoryPath + "/database/java/" + year;
                    Set<String> files = listFilesUsingDirectoryStream(pathToYearDir);
                    for (String file : files) {
                        String content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                        YAMLHandler.JavaVulnMapper javaPgk = javaYaml.load(content);
                        // Parse only if it has not been enriched before
                        if (dictionary.get(javaPgk.cve) == null) {
                            // Check if you already have versions from the VersionRanger
                            List<String> versionsPgk = versionRanger.getVersions("/maven/" +
                                    javaPgk.affected.get(0).groupId + "/" +
                                    javaPgk.affected.get(0).artifactId);
                            // Find vulnerable versions and create purls in the mappings
                            List<String> vulnerableVersions = versionRanger.getVulnerableVersionsYAML(javaPgk.affected.get(0).version, versionsPgk);
                            HashSet<String> vulnerablePURL = versionRanger.buildPURLSMaven(javaPgk.affected.get(0), vulnerableVersions);
                            dictionary.put("CVE-" + javaPgk.cve, vulnerablePURL);
                        }
                    }
                } catch (IOException e) {
                    System.out.println("Could not list any files for year: " + year);
                }
            }
            // Parse Python Database
            Yaml pythonYaml = new Yaml(new Constructor(YAMLHandler.PythonVulnMapper.class));
            String[] yearsPython = new File(cloneDirectoryPath + "/database/python").list();
            for (String year : yearsPython) {
                try {
                    String pathToYearDir = cloneDirectoryPath + "/database/python/" + year;
                    Set<String> files = listFilesUsingDirectoryStream(pathToYearDir);
                    for (String file : files) {
                        String content = Files.readString(Paths.get(pathToYearDir + "/" + file));
                        YAMLHandler.PythonVulnMapper pythonPgk = pythonYaml.load(content);
                        // Parse only if it has not been enriched before
                        if (dictionary.get(pythonPgk.cve) == null) {
                            // Check if you already have versions from the VersionRanger
                            List<String> versionsPgk = versionRanger.getVersions("/pypi/" + pythonPgk.affected.get(0).name);
                            // Find vulnerable versions and create purls in the mappings
                            List<String> vulnerableVersions = versionRanger.getVulnerableVersionsYAML(pythonPgk.affected.get(0).version, versionsPgk);
                            HashSet<String> vulnerablePURL = versionRanger.buildPURLSPypi(pythonPgk.affected.get(0), vulnerableVersions);
                            dictionary.put("CVE-" + pythonPgk.cve, vulnerablePURL);
                        }
                    }
                } catch (IOException e) {
                    System.out.println("Could not list any files for year: " + year);
                }
            }
        } catch (GitAPIException e) {
            e.printStackTrace();
        }
    }


    public void injectGithubAdvisories() {
        ObjectMapper objectMapper = new ObjectMapper();
        var token = "your_api_token"; // this will later be passed as an env variable
        String queryWithoutCursor = "query withoutCursor {\n" +
                "  securityAdvisories(first: 100) {\n" +
                "    nodes {\n" +
                "      description\n" +
                "      identifiers {\n" +
                "        type\n" +
                "        value\n" +
                "      }\n" +
                "      severity\n" +
                "      references {\n" +
                "        url\n" +
                "      }\n" +
                "      vulnerabilities(first: 1) {\n" +
                "        nodes {\n" +
                "          package {\n" +
                "            ecosystem\n" +
                "            name\n" +
                "          }\n" +
                "          vulnerableVersionRange\n" +
                "        }\n" +
                "      }\n" +
                "    }\n" +
                "    pageInfo {\n" +
                "      endCursor\n" +
                "      hasNextPage\n" +
                "    }\n" +
                "  }\n" +
                "}";
        // Step 1: Make the first request without any cursor
        var values = new HashMap<String, String>();
        values.put("query", queryWithoutCursor);
        try {
            String result = client.sendPost("https://api.github.com/graphql", token, values);
            JSONHandler.GHResponse response = objectMapper.readValue(result, JSONHandler.GHResponse.class);
            System.out.println(response.data.securityAdvisories.pageInfo.endCursor);
        } catch (Exception e) {
            e.printStackTrace();
        }
        // Step 2: Integrate the request with the cursor and parse the data

        //TODO: Parse the body of the result and set the cursor the keep it moving
        //TODO: Assess how many tokens are necessary
    }

    /**
     * Builds a query for GraphQL API setting a cursor
     * @param cursor
     * @return
     */
    public String buildQueryWithCursor(String cursor) {
        return "query withCursor {\n" +
                "  securityAdvisories(first: 100, after: \""+ cursor +"\") {\n" +
                "    nodes {\n" +
                "      description\n" +
                "      identifiers {\n" +
                "        type\n" +
                "        value\n" +
                "      }\n" +
                "      severity\n" +
                "      references {\n" +
                "        url\n" +
                "      }\n" +
                "      vulnerabilities(first: 1) {\n" +
                "        nodes {\n" +
                "          package {\n" +
                "            ecosystem\n" +
                "            name\n" +
                "          }\n" +
                "          vulnerableVersionRange\n" +
                "        }\n" +
                "      }\n" +
                "    }\n" +
                "    pageInfo {\n" +
                "      endCursor\n" +
                "      hasNextPage\n" +
                "    }\n" +
                "  }\n" +
                "}";
    }

    /**
     * Helper function to get all the files in a directory.
     * @param dir path to the directory to list files
     * @return Set of Strings where each string is a file name of a YAML file with a vulnerability
     * @throws IOException
     */
    public Set<String> listFilesUsingDirectoryStream(String dir) throws IOException {
        Set<String> fileList = new HashSet<>();
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(dir))) {
            for (Path path : stream) {
                if (!Files.isDirectory(path)) {
                    if (!path.getFileName().toString().equals(".gitkeep")) {
                        fileList.add(path.getFileName()
                                .toString());
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return fileList;
    }

    public void pullUpdates() {

    }

    public void updateDictionary() {
        // TODO: daily method to update the mapper before parsing the vulnerability with the Parser
    }

    public static void main(String[] args) {
        CVEMapper cm = new CVEMapper(new JavaHttpClient());
        int counter = 0;
        while (counter < 20) {
            cm.injectGithubAdvisories();
            counter += 1;
        }
    }
}
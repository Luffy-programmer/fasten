/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.utils;

import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.zip.GZIPInputStream;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import com.opencsv.CSVReader;
import org.apache.commons.lang3.StringUtils;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.jooq.tools.json.JSONParser;
import org.jooq.tools.json.ParseException;
import org.jooq.tools.json.JSONObject;
import org.owasp.dependencycheck.data.nvd.json.DefCpeMatch;
import org.owasp.dependencycheck.data.nvd.json.DefCveItem;
import org.owasp.dependencycheck.data.nvd.json.DefNode;
import org.owasp.dependencycheck.data.nvd.json.Reference;
import org.owasp.dependencycheck.utils.DownloadFailedException;
import org.owasp.dependencycheck.utils.Downloader;
import org.owasp.dependencycheck.utils.ResourceNotFoundException;
import org.owasp.dependencycheck.utils.TooManyRequestsException;

import static com.mongodb.client.model.Filters.and;
import static com.mongodb.client.model.Filters.eq;
import static java.nio.charset.StandardCharsets.UTF_8;

public class Parser {

    public static JSONParser jsonParser;
    public static MongoCollection<Document> mongoCommitsCollection;
    public static MongoCollection<Document> mongoPullRequestsCollection;
    public static MongoCollection<Document> mongoIssuesCollection;
    public static JavaHttpClient httpClient;
    public static HashMap<String, String> extraCommits;

    /**
     * Takes a MongoDatabase object to connect and retrieve collections from.
     */
    public Parser(MongoDatabase db, JavaHttpClient client) {
        httpClient = client;
        jsonParser = new JSONParser();
        mongoCommitsCollection = db.getCollection("commits");
        mongoPullRequestsCollection = db.getCollection("pull_requests");
        mongoIssuesCollection = db.getCollection("issues");
        extraCommits = new HashMap<>();
    }

    /**
     * Unzip and Parsing of NVD Json information.
     *
     * @param gzip File with path pointing to the GZIP file
     *             e.g. File raw = new File("./analyzer/vulnerability-plugin/src/main/resources/nvdcve-1.1-2005.json.gz");
     * @return List of Vulnerabilities parsed
     * @throws IOException in the case where the file is not a zip file
     */
    public List<DefCveItem> parseCVEZip(File gzip) throws IOException {

        List<DefCveItem> cves = new ArrayList<>();

        InputStream fin = new FileInputStream(gzip);
        InputStream in = new GZIPInputStream(fin);
        InputStreamReader isr = new InputStreamReader(in, UTF_8);
        JsonReader reader = new JsonReader(isr);

        final Gson gson = new GsonBuilder().create();
        reader.beginObject();

        while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {
            reader.skipValue();
        }
        reader.beginArray();
        while (reader.hasNext()) {
            cves.add(gson.fromJson(reader, DefCveItem.class));
        }
        return cves;
    }

    /**
     * Downloads CVE json Data Feed from 2002 until current year.
     *
     * @param downloader - dependency injection for testing
     * @return a list of the paths where the gzip files are stored.
     * @throws MalformedURLException     - URL is not accessible
     * @throws TooManyRequestsException  - too many requests are performed
     * @throws DownloadFailedException   - download fails
     * @throws ResourceNotFoundException - resource cannot be found
     */
    public List<File> downloadCVEs(Downloader downloader) throws MalformedURLException,
            TooManyRequestsException,
            DownloadFailedException,
            ResourceNotFoundException {
        int currentYear = LocalDate.now().getYear();
        List<File> paths = new ArrayList<>();
        for (int i = 2002; i <= currentYear; i++) {
            URL cve_url = new URL("https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-" + i + ".json.gz");
            File out_path = new File("./analyzer/vulnerability-plugin/src/main/resources/nvd/nvdcve-1.1-" + i + ".json.gz");
            downloader.fetchFile(cve_url, out_path);
            paths.add(out_path);
        }
        return paths;
    }

    /**
     * Downloads updates from NVD JSON Data Feed.
     *
     * @param downloader - dependency injection for testing
     * @return Path to the saved file
     * @throws MalformedURLException     - URL is not accessible
     * @throws TooManyRequestsException  - too many requests are performed
     * @throws DownloadFailedException   - download fails
     * @throws ResourceNotFoundException - resource cannot be found
     */
    public File downloadUpdates(Downloader downloader) throws MalformedURLException,
            TooManyRequestsException,
            DownloadFailedException,
            ResourceNotFoundException {
        URL updates_url = new URL("https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-modified.json.gz");
        File out_path = new File("./analyzer/vulnerability-plugin/src/main/resources/nvd/nvdcve-1.1-modified.json.gz");
        downloader.fetchFile(updates_url, out_path);
        return out_path;
    }

    /**
     * Parses all the additional files in the resources/datasets folder.
     * @param extraCommitsFile - "./analyzer/vulnerability-plugin/src/main/resources/datasets/extra_commits.csv"
     */
    public void parseDatasets(String extraCommitsFile) {
        // Add additional commits
        CSVReader reader = null;
        try {
            reader = new CSVReader(new FileReader(extraCommitsFile));
            String[] line;
            while ((line = reader.readNext()) != null) {
                // line[0] contains the ID of the CVE
                // line[2] contains the SHA of the commits
                String commitUrl = line[1] + "/commit/" + line[2];
                extraCommits.put(line[0], commitUrl);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Parses cpe23Uri String extracting necessary information.
     *
     * @param vulnerability - Vulnerability Object to inject cpe23Uri
     * @param cpe23Uri      - String to parse
     */
    public void injectCpeInfo(Vulnerability vulnerability, String cpe23Uri) {
        String[] data = cpe23Uri.split(":");
        String vendor = data[3];
        String product = data[4];
        String version = data[5];

        // Add Cpe23Uri to Vulnerability Object
        vulnerability.addCpeUri(new Vulnerability.Cpe23Uri(vendor, product, version));
    }

    /**
     * Sends GET request to vulncode-db and retrieves relevant files.
     *
     * @param cveId - ID of the CVE entry to query.
     * @return List<String> containing files.
     */
    public List<String> getRelevantFiles(String cveId) {
        List<String> files = new ArrayList<>();
        String jsonBody = null;
        try {
            jsonBody = httpClient.sendGet("https://www.vulncode-db.com/api/v1/" + cveId);
        } catch (Exception e) {
            System.out.println("Error: Invalid endpoint");
        }
        try {
            Object obj = jsonParser.parse(jsonBody);
            JSONObject payload = (JSONObject) obj;
            Object masterCommitObj = payload.get("master_commit");
            JSONObject masterCommit = (JSONObject) masterCommitObj;
            if (masterCommit != null && masterCommit.get("relevant_files") != null) {
                files = (List<String>) masterCommit.get("relevant_files");
            }
        } catch (ParseException e) {
            System.out.println("Error while parsing");
        }
        return files;
    }

    /**
     * Extracts information from each DefCveItem and inject it into Vulnerability Objects
     *
     * @param cveItem - see DefCveItem class for more information
     * @return the parsed and enriched vulnerability
     */
    public Vulnerability parseVulnerability(DefCveItem cveItem) {
        Vulnerability vulnerability = new Vulnerability(cveItem.getCve().getCVEDataMeta().getId());
        vulnerability.setDescription(cveItem.getCve().getDescription().getDescriptionData().get(0).getValue());
        if (cveItem.getImpact().getBaseMetricV2() != null) {
            vulnerability.setScoreCVSS2(cveItem.getImpact().getBaseMetricV2().getCvssV2().getBaseScore());
        }
        if (cveItem.getImpact().getBaseMetricV3() != null) {
            vulnerability.setScoreCVSS3(cveItem.getImpact().getBaseMetricV3().getCvssV3().getBaseScore());
        }
        vulnerability.setPublishedDate(cveItem.getPublishedDate());
        vulnerability.setLastModifiedDate(cveItem.getLastModifiedDate());
        for (DefNode node : cveItem.getConfigurations().getNodes()) {
            for (DefCpeMatch match : node.getCpeMatch()) {
                injectCpeInfo(vulnerability, match.getCpe23Uri());
            }
        }
        // Adding Patch links, Exploit links or other references
        for (Reference ref : cveItem.getCve().getReferences().getReferenceData()) {
            if (ref.getTags().contains("Exploit")) {
                vulnerability.addExploit(ref.getUrl());
            } else if (ref.getTags().contains("Patch")) {
                vulnerability.addPatch(ref.getUrl());
            } else {
                vulnerability.addReference(ref.getUrl());
            }
        }
        // Enrich with dataset from here: https://arxiv.org/abs/1902.02595
        enrichInformation(vulnerability);

        // Parse all
        for (String ref : vulnerability.getReferences()) {
            // Case 1: Git commit
            if (ref.matches("https://github\\.com/.*/.*/commit/.*")) {
                parseCommit(vulnerability, ref);
            }
            // Case 2: Git Pull request
            if (ref.matches("https://github\\.com/.*/.*/pull/.*")) {
                parsePullRequest(vulnerability, ref);
            }
            // Case 3: Git Issues
            if (ref.matches("https://github\\.com/.*/.*/issues/.*")) {
                parseIssues(vulnerability, ref);
            }
        }
        return vulnerability;
    }

    /**
     * Enriches the vulnerability with information found from Research.
     * 1. Commits found here: https://arxiv.org/abs/1902.02595
     * @param vulnerability - to inject information into
     */
    private void enrichInformation(Vulnerability vulnerability) {
        vulnerability.addPatch(extraCommits.get(vulnerability.getId()));
    }

    /**
     * Extracts information from Pull Request links.
     * First queries GHTorrent and if nothing is found use Github API
     *
     * @param vulnerability object to inject information
     * @param pr            github link to the pull request
     */
    public void parsePullRequest(Vulnerability vulnerability, String pr) {
        String jsonBody;
        try {
            // Extract information from the patch and create API Link
            String[] infoPatch = pr.split("/");
            String repoOwner = infoPatch[3];
            String repoName = infoPatch[4];
            String prNumber = infoPatch[6];
            // Query GHTorrent to find the corresponding Pull Request
            Bson filter = and(eq("repo", repoName),
                    eq("owner", repoOwner),
                    eq("number", prNumber));
            jsonBody = mongoPullRequestsCollection.find(filter).first().toJson();

            // If GhTorrent does not find it, query Github API
            if (jsonBody == null) {
                String apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/pulls/" + prNumber;
                // Send GET request
                jsonBody = httpClient.sendGet(apiLink);
                // TODO: If it was not on GHTorrent, write it in there (?)
            }

            // Look for a merge_commit_sha and use the parseCommit function
            // Parse the result and extract data
            JSONParser jsonParser = new JSONParser();
            Object obj = jsonParser.parse(jsonBody);
            JSONObject payload = (JSONObject) obj;
            if (payload.get("merge_commit_sha") != null) {
                // There is a commit we can parse
                String mergeCommitSHA = (String) payload.get("merge_commit_sha");
                String urlCommit = "https://github.com/" + repoOwner + "/" + repoName + "/commit/" + mergeCommitSHA;
                this.parseCommit(vulnerability, urlCommit);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Method parses Github issues links found in the vulnerability references.
     *
     * @param vulnerability - to inject information into
     * @param issue         - link of the issue e.g. https://github.com/restlet/restlet-framework-java/issues/774
    *
    * The script looks for a pull_request field in the json corresponding to the issue.
    * "pull_request": {
    *   "url": "https://api.github.com/repos/python/cpython/pulls/32",
    *   "html_url": "https://github.com/python/cpython/pull/32",
    *   "diff_url": "https://github.com/python/cpython/pull/32.diff",
    *   "patch_url": "https://github.com/python/cpython/pull/32.patch"
    *  }
    *  Once the pull_request field is found, we parse the PR, which will lead to a commit.
    */
    public void parseIssues(Vulnerability vulnerability, String issue) {
        String jsonBody;
        try {
            // Extract information from the patch and create API Link
            String[] infoPatch = issue.split("/");
            String repoOwner = infoPatch[3];
            String repoName = infoPatch[4];
            String issueNumber = infoPatch[6];
            // Query GHTorrent to find the corresponding Pull Request
            jsonBody = mongoIssuesCollection.find(and(eq("repo", repoName),
                    eq("owner", repoOwner), eq("number", issueNumber))).first().toJson();

            // If GhTorrent does not find it, query Github API
            if (jsonBody == null) {
                String apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/issues/" + issueNumber;
                // Send GET request
                jsonBody = httpClient.sendGet(apiLink);
                // TODO: If it was not on GHTorrent, write it in there (?)
            }

            // Look for a pull_request and use the parsePullRequest function
            // Parse the result and extract data
            JSONParser jsonParser = new JSONParser();
            Object obj = jsonParser.parse(jsonBody);
            JSONObject payload = (JSONObject) obj;
            if (payload.get("pull_request") != null) {
                // There is a commit we can parse
                JSONObject pullRequest = (JSONObject) payload.get("pull_request");
                String urlPullRequest = (String) pullRequest.get("html_url");
                this.parsePullRequest(vulnerability, urlPullRequest);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Parses patch links to git commits using GitHub API v3.
     * Extracts the following information:
     * - files changed
     * - methods affected
     * - days it took to fix
     *
     * @param vulnerability object to inject information
     * @param patchLink     URL to the git commit
     */
    public void parseCommit(Vulnerability vulnerability, String patchLink) {
        String jsonBody;
        try {
            // Extract information from the patch and create API Link
            String[] infoPatch = patchLink.split("/");
            String commitHash = infoPatch[6];
            // Query GHTorrent with the hash of the commit
            jsonBody = mongoCommitsCollection.find(eq("sha", commitHash)).first().toJson();

            // If GHTorrent does not find it, query Github API
            if (jsonBody == null) {
                String repoOwner = infoPatch[3];
                String repoName = infoPatch[4];
                String apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/commits/" + commitHash;
                // Send GET request
                jsonBody = httpClient.sendGet(apiLink);
                // TODO: If it was not on GHTorrent, write it in there (?)
            }

            // Parse the result and extract data
            JSONParser jsonParser = new JSONParser();
            Object obj = jsonParser.parse(jsonBody);
            JSONObject payload = (JSONObject) obj;
            JSONObject commit = (JSONObject) payload.get("commit");
            JSONObject author = (JSONObject) commit.get("author");
            String date = (String) author.get("date");
            vulnerability.setDaysToFix(getDurationFixing(date, vulnerability.getPublishedDate()));
            List<Object> files = (List<Object>) payload.get("files");
            for (Object file : files) {
                JSONObject fileObj = (JSONObject) file;
                String filenameChanged = (String) fileObj.get("filename");
                if (fileObj.get("patch") != null) {
                    List<Vulnerability.Hunk> hunks = getPatchHunks(fileObj.get("patch").toString(), date);
                    // TODO: Check if the File already exists --> add to it in that case
                    vulnerability.addVulnerableFile(new Vulnerability.File(filenameChanged, hunks, date));
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Extracts the hunks from the commit information.
     *
     * @param patch     - String representing the patch information
     * @param patchDate - Date when the patch was applied
     * @return
     */
    private List<Vulnerability.Hunk> getPatchHunks(String patch, String patchDate) {
        List<Vulnerability.Hunk> linesAffected = new ArrayList<>();
        String[] linesPatch = patch.split("\n");
        for (String line : linesPatch) {
            String hunk = StringUtils.substringBetween(line, "@@");
            if (hunk != null) {
                int lineNumber = Integer.parseInt(hunk.split(",")[0].split("-")[1]);
                linesAffected.add(new Vulnerability.Hunk(lineNumber, patchDate));
            }
        }
        return linesAffected;
    }

    /**
     * Given two string representing dates, returns the difference in time between them.
     *
     * @param date          of the commit
     * @param publishedDate when the vulnerability was published
     * @return days it took to fix the vulnerability
     */
    private Long getDurationFixing(String date, String publishedDate) {
        String dateCommitString = date.substring(0, 10);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        try {
            Date dateCommit = sdf.parse(dateCommitString);
            Date datePublished = sdf.parse(publishedDate);
            long diff = dateCommit.getTime() - datePublished.getTime();
            return TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
        } catch (java.text.ParseException e) {
            System.out.println("Date format is wrong");
        }
        return null;
    }

    /**
     * Helper function for the vulnerability Plugin to inject the sleep behaviour.
     * This way, when mocking the parser, you can just skip over the wait.
     */
    public void sleep() {
        try {
            TimeUnit.DAYS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

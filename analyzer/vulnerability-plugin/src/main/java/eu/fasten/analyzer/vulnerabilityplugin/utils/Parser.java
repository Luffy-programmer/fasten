package eu.fasten.analyzer.vulnerabilityplugin.utils;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import org.jooq.tools.json.JSONParser;
import org.jooq.tools.json.ParseException;
import org.jooq.tools.json.JSONObject;
import org.owasp.dependencycheck.data.nvd.json.DefCpeMatch;
import org.owasp.dependencycheck.data.nvd.json.DefCveItem;
import org.owasp.dependencycheck.data.nvd.json.DefNode;
import org.owasp.dependencycheck.data.nvd.json.Reference;
import org.owasp.dependencycheck.utils.*;

import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.zip.GZIPInputStream;

import static eu.fasten.analyzer.vulnerabilityplugin.utils.JavaHttpClient.sendGet;
import static java.nio.charset.StandardCharsets.UTF_8;

public class Parser {

    public static JSONParser jsonParser;

    public Parser() {
        jsonParser = new JSONParser();
    }

    /**
     * Unzip and Parsing of NVD Json information.
     *
     * @param gzip File with path pointing to the GZIP file
     *             e.g. File raw = new File("./analyzer/vulnerability-plugin/src/main/resources/nvdcve-1.1-2005.json.gz");
     * @return List of Vulnerabilities parsed
     * @throws IOException
     */
    public static List<DefCveItem> parseCVEZip(File gzip) throws IOException {

        List<DefCveItem> cves = new ArrayList<>();

        InputStream fin = new FileInputStream(gzip);
        InputStream in = new GZIPInputStream(fin);
        InputStreamReader isr = new InputStreamReader(in, UTF_8);
        JsonReader reader = new JsonReader(isr);

        final Gson gson = new GsonBuilder().create();
        reader.beginObject();

        while (reader.hasNext() && !JsonToken.BEGIN_ARRAY.equals(reader.peek())) {
            reader.skipValue();
        }
        reader.beginArray();
        while (reader.hasNext()) {
            cves.add(gson.fromJson(reader, DefCveItem.class));
        }
        return cves;
    }

    /**
     * Downloads CVE json Data Feed from 2002 until current year.
     *
     * @param downloader - dependency injection for testing
     * @return a list of the paths where the gzip files are stored.
     * @throws MalformedURLException
     * @throws TooManyRequestsException
     * @throws DownloadFailedException
     * @throws ResourceNotFoundException
     */
    public static List<File> downloadCVEs(Downloader downloader) throws MalformedURLException,
            TooManyRequestsException,
            DownloadFailedException,
            ResourceNotFoundException {
        int currentYear = LocalDate.now().getYear();
        List<File> paths = new ArrayList<>();
        for (int i = 2002; i <= currentYear; i++) {
            URL cve_url = new URL("https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-" + i + ".json.gz");
            File out_path = new File("./analyzer/vulnerability-plugin/src/main/resources/nvd/nvdcve-1.1-" + i + ".json.gz");
            downloader.fetchFile(cve_url, out_path);
            paths.add(out_path);
        }
        return paths;
    }

    /**
     * Downloads updates from NVD JSON Data Feed.
     *
     * @param downloader - dependency injection for testing
     * @return Path to the saved file
     * @throws MalformedURLException
     * @throws TooManyRequestsException
     * @throws DownloadFailedException
     * @throws ResourceNotFoundException
     */
    public static File downloadUpdates(Downloader downloader) throws MalformedURLException,
            TooManyRequestsException,
            DownloadFailedException,
            ResourceNotFoundException {
        URL updates_url = new URL("https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-modified.json.gz");
        File out_path = new File("./analyzer/vulnerability-plugin/src/main/resources/nvd/nvdcve-1.1-modified.json.gz");
        downloader.fetchFile(updates_url, out_path);
        return out_path;
    }

    /**
     * Parses cpe23Uri String extracting necessary information.
     *
     * @param vulnerability - Vulnerability Object to inject cpe23Uri
     * @param cpe23Uri      - String to parse
     */
    public static void injectCpeInfo(Vulnerability vulnerability, String cpe23Uri) {
        String[] data = cpe23Uri.split(":");
        String vendor = data[3];
        String product = data[4];
        String version = data[5];

        // Add Cpe23Uri to Vulnerability Object
        vulnerability.addCpeUri(new Vulnerability.Cpe23Uri(vendor, product, version));
    }

    /**
     * Sends GET request to vulncode-db and retrieves relevant files.
     *
     * @param cveId  - ID of the CVE entry to query.
     * @param client - JavaHttpClient, injectable to facilitate testing.
     * @return List<String> containing files.
     */
    public static List<String> getRelevantFiles(String cveId, JavaHttpClient client) {
        List<String> files = new ArrayList<>();
        String json_body = null;
        try {
            json_body = sendGet("https://www.vulncode-db.com/api/v1/" + cveId);
        } catch (Exception e) {
            System.out.println("Error: Invalid endpoint");
        }
        try {
            Object obj = jsonParser.parse(json_body);
            JSONObject payload = (JSONObject) obj;
            Object master_commit_obj = payload.get("master_commit");
            JSONObject master_commit = (JSONObject) master_commit_obj;
            if (master_commit != null && master_commit.get("relevant_files") != null) {
                files = (List<String>) master_commit.get("relevant_files");
            }
        } catch (ParseException e) {
            System.out.println("Error while parsing");
        }
        return files;
    }

    /**
     * Extracts information from each DefCveItem and inject it into Vulnerability Objects
     *
     * @param cveItems - see DefCveItem class for more information
     * @return a list of Vulnerabilities, ready to be produced by the plugin
     */
    public static List<Vulnerability> parseVulnerabilities(List<DefCveItem> cveItems) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        for (DefCveItem cveItem : cveItems) {
            System.out.println("Pumping: " + cveItem.getCve().getCVEDataMeta().getId());
            Vulnerability vulnerability = new Vulnerability(cveItem.getCve().getCVEDataMeta().getId());
            vulnerability.setDescription(cveItem.getCve().getDescription().getDescriptionData().get(0).getValue());
            if (cveItem.getImpact().getBaseMetricV2() != null) {
                vulnerability.setScoreCVSS2(cveItem.getImpact().getBaseMetricV2().getCvssV2().getBaseScore());
            }
            if (cveItem.getImpact().getBaseMetricV3() != null) {
                vulnerability.setScoreCVSS3(cveItem.getImpact().getBaseMetricV3().getCvssV3().getBaseScore());
            }
            vulnerability.setPublishedDate(cveItem.getPublishedDate());
            vulnerability.setLastModifiedDate(cveItem.getLastModifiedDate());
            for (DefNode node : cveItem.getConfigurations().getNodes()) {
                for (DefCpeMatch match : node.getCpeMatch()) {
                    injectCpeInfo(vulnerability, match.getCpe23Uri());
                }
            }
            // Adding Patch links, Exploit links or other references
            for (Reference ref : cveItem.getCve().getReferences().getReferenceData()) {
                if (ref.getTags().contains("Exploit")) {
                    vulnerability.addExploit(ref.getUrl());
                } else if (ref.getTags().contains("Patch")) {
                    vulnerability.addPatch(ref.getUrl());
                } else {
                    vulnerability.addReference(ref.getUrl());
                }
            }
//            vulnerability.setVulnerable_files(getRelevantFiles(vulnerability.getId(), new JavaHttpClient()));
            for (String patch : vulnerability.getPatches()) {
                if (patch.matches("https://github\\.com/.*/.*/commit/.*")) {
                    parseCommit(vulnerability, patch);
                }
            }
            vulnerabilities.add(vulnerability);
        }
        return vulnerabilities;
    }

    /**
     * Parses patch links to git commits using GitHub API v3.
     * Extracts the following information:
     *      - files changed
     *      - methods affected
     *      - days it took to fix
     * @param vulnerability object to inject information
     * @param patch URL to the git commit
     */
    private static void parseCommit(Vulnerability vulnerability, String patch) {
        String json_body;
        try {
            // Extract information from the patch and create API Link
            String[] infoPatch = patch.split("/");
            String repoOwner = infoPatch[3];
            String repoName = infoPatch[4];
            String commitHash = infoPatch[6];
            String apiLink = "https://api.github.com/repos/" + repoOwner + "/" + repoName + "/commits/" + commitHash;
            // Send GET request
            json_body = sendGet(apiLink);
            // Parse the result and extract data
            JSONParser jsonParser = new JSONParser();
            Object obj = jsonParser.parse(json_body);
            JSONObject payload = (JSONObject) obj;
            JSONObject commit = (JSONObject) payload.get("commit");
            JSONObject author = (JSONObject) commit.get("author");
            String date = (String) author.get("date");
            vulnerability.setDaysToFix(getDurationFixing(date, vulnerability.getPublishedDate()));
            List<Object> files = (List<Object>) payload.get("files");
            for (Object file : files) {
                JSONObject fileObj = (JSONObject) file;
                String filenameChanged = (String) fileObj.get("filename");
                String methodChanged = fileObj.get("patch").toString().split("\n")[0].split("@@")[2].substring(1);
                vulnerability.addVulnerableFile(new Pair<>(filenameChanged, methodChanged));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Given two string representing dates, returns the difference in time between them.
     * @param date of the commit
     * @param publishedDate when the vulnerability was published
     * @return days it took to fix the vulnerability
     */
    private static Long getDurationFixing(String date, String publishedDate) {
        String dateCommitString = date.substring(0, 10);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        try {
            Date dateCommit = sdf.parse(dateCommitString);
            Date datePublished = sdf.parse(publishedDate);
            long diff = dateCommit.getTime() - datePublished.getTime();
            return TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
        } catch (java.text.ParseException e) {
            System.out.println("Date format is wrong");
        }
        return null;
    }

    /**
     * Testing how to retrieve exploit information
     *
     * @param args
     */
    public static void main(String[] args) {
        List<File> paths = null;

        // Step 1: Download all gzip files from NVD
        try {
            paths = Parser.downloadCVEs(new Downloader(new Settings(new Properties())));
        } catch (Exception e) {
            System.out.println("OOF");
        }

        // Step 2: Parse them into DefCveItems
        List<DefCveItem> rawCves = new ArrayList<>();
        try {
            for (File path : paths) {
                rawCves.addAll(Parser.parseCVEZip(path));
            }
        } catch (IOException e) {
            System.out.println("Error while parsing gzip files");
        }

        // Step 3: Translate into Vulnerability class
        List<Vulnerability> vulnerabilities = Parser.parseVulnerabilities(rawCves);
    }
}

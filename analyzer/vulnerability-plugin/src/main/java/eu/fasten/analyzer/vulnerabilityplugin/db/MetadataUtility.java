/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.db;

import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.PURLPackage;
import eu.fasten.core.data.metadatadb.MetadataDao;
import eu.fasten.core.data.metadatadb.codegen.tables.records.PackageVersionsRecord;
import eu.fasten.core.data.metadatadb.codegen.tables.records.PackagesRecord;
import org.jooq.DSLContext;
import org.jooq.JSONB;
import org.jooq.Record;
import org.jooq.Result;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class MetadataUtility {

    private MetadataDao metadataDao;
    private DSLContext dslContext;
    private final Logger logger = LoggerFactory.getLogger(MetadataUtility.class.getName());

    public MetadataUtility(DSLContext dslContext) {
        this.dslContext = dslContext;
        this.metadataDao = new MetadataDao(dslContext);
    }

    /**
     * Method to inject the information contained in a Vulnerability Object.
     * The following explains the logic used to insert the information:
     * First, the information at the package level is injected. This is done by looping through
     * all the purls contained in the object. We store the IDs of the package_version row.
     *
     * Second, we try to find the callables responsible.
     * @param v
     */
    public void injectVulnerabilityIntoDB(Vulnerability v) {
        logger.info("Injecting vulnerability " + v.getId() + " into the Database");
        // Inject all the info at the package-level and store packageVersionsId
        HashMap<String, Long> pkgIds = new HashMap<>();
        String lastVersionPurl = null;

        for (String purl : v.getPurls()) {
            Long pkgId = getPackageVersionId(purl);
            if (pkgId > 0) {
                logger.info("Injecting into the DB Package Version with ID: " + pkgId);
                metadataDao.injectPackageVersionVulnerability(v.toJson(), pkgId);
                pkgIds.put(purl, pkgId);

                // Compare to get the last version of purl
                if (lastVersionPurl != null) {
                    if (purl.compareTo(lastVersionPurl) > 0) {
                        lastVersionPurl = purl;
                    }
                } else {
                    lastVersionPurl = purl;
                }
            }
        }

        // For each of the files changed in the patches of the vulnerability
        // Find the FastenURI of the callable for the "first" purl
        // Propagate the same information at the callables for the other purls.
        if (lastVersionPurl != null) {
            for (Vulnerability.File file : v.getVulnerableFiles()) {
                logger.info("Searching for callables found in " + file.getFileName()
                        + " in purl:" + lastVersionPurl);
                // Get the fasten_uri from the most recent vulnerable versions
                List<String> fastenURIs = getFastenUrisForVulnerability(file, pkgIds.get(lastVersionPurl));
                // Propagate the same to the earlier versions changing the fastenURI
                logger.info("Found " + fastenURIs.size() + " fasten_uris to propagate in other versions");
                for (String uri : fastenURIs) {
                    // Get all the callables with the fasten_uri
                    List<Long> callableIds = metadataDao.getCallableIdsForFastenUri(uri);
                    // Inject the metadata in the callable row
                    for (Long id : callableIds) {
                        logger.info("Injecting into DB Callable with ID: " + id);
                        metadataDao.injectCallableVulnerability(v.toJson(), id);
                    }
                }
            }
        }
    }

    /**
     * Given a file and a package version id, looks for each hunk in the file.
     * The fasten_uri of each callable that is found at the linenumber indicated in the hunk
     * is then stored and returned.
     * @param file - that contains hunks with the changes to the file
     * @param pkgVersionId - Long - ID of the package version
     * @return List of fastenURIs to
     */
    private List<String> getFastenUrisForVulnerability(Vulnerability.File file, Long pkgVersionId) {
        List<String> fastenURIs = new ArrayList<>();

        // Get the fileID
        Long fileId = metadataDao.getFileId(pkgVersionId, file.getFileName());
        if (fileId < 0) return fastenURIs;

        // There could be more moduleIds for the same file
        List<Long> moduleIds = metadataDao.getModuleIds(fileId);
        logger.info("Found " + moduleIds.size() + " modules corresponding to file with id " + fileId);

        for (Long moduleId : moduleIds) {
            // Get callables information for the file
            // We need to know the fasten_uri + first + last
            List<CallableHolder> callableHolders = getCallablesInformation(moduleId);

            // For each hunk, get the line number and look in the callables table
            for (Vulnerability.Hunk hunk : file.getHunks()) {
                // Find the callable
                CallableHolder callable = getCallableThatContainsLine(callableHolders, hunk.getLineNumber());
                if (callable != null) {
                    // Store fastenURI for later use
                    logger.info("Found vulnerable callable with fasten_uri: " + callable.getFastenURI());
                    fastenURIs.add(callable.getFastenURI());
                }
            }
        }

        return fastenURIs;
    }

    /**
     * Finds the callable that interests the specific line number we are looking at.
     * @param callableHolders - list of CallableHolders
     * @param lineNumber - Integer line number where the change was made
     * @return CallableHolder object
     */
    private CallableHolder getCallableThatContainsLine(List<CallableHolder> callableHolders, int lineNumber) {
        for (CallableHolder ch : callableHolders) {
            if (ch.getFirst() <= lineNumber && ch.getLast() >= lineNumber) {
                return ch;
            }
        }
        return null;
    }

    /**
     * Retrieves the callables information to use them later.
     * @param moduleId - Long ID of the file where the callable was changed.
     * @return Long ID of the callable (-1L if it cannot find it)
     */
    private List<CallableHolder> getCallablesInformation(Long moduleId) {
        List<CallableHolder> calls = new ArrayList<>();
        // Get all the records with the moduleId given
        Result<Record> crs = metadataDao.getCallablesInModule(moduleId);
        for (Record cr : crs) {
            Long callableId = (Long) cr.get(0);
            String fastenUri = (String) cr.get(2);
            JSONB metadata = (JSONB) cr.get(5);
            JSONObject obj = new JSONObject(metadata.data());
            int first = (int) obj.get("first");
            int last = (int) obj.get("last");

            // Create callable object and store it
            CallableHolder ch = new CallableHolder(callableId,
                    fastenUri, first, last);

            calls.add(ch);
        }
        return calls;
    }

    /**
     * Retrieves the package_version_id given the purl of the package version.
     * @param purl - follows purl specifications
     * @return negative if it cannot be found
     */
    private Long getPackageVersionId(String purl) {
        logger.info("Looking for package_version_id of " + purl);
        // Check if the package exists
        // Step 0: Brake down purl to get the information you need
        PURLPackage packageObject = PURLPackage.getObjectFromPurl(purl);

        if (packageObject.getType().equals("mvn")) {
            // Step 1: Find package ID of the package with specific name
            String mvnCoordinate = packageObject.getNamespace() + ":" + packageObject.getName();
            PackagesRecord packageRecord = metadataDao.getPackageIdFromCoordinate(
                    mvnCoordinate,
                    packageObject.getType());

            if (packageRecord != null) {
                // Find the package version record
                PackageVersionsRecord pgkVersionRecord = metadataDao.getPackageVersionIdFromVersion(
                        packageRecord.component1(),
                        packageObject.getVersion());

                if (pgkVersionRecord != null) {
                    return pgkVersionRecord.getId();
                }
            }
        }
        if (packageObject.getType().equals("PyPI")) {
            //TODO: Implement checks for Python packages to find the package
        }
        if (packageObject.getType().equals("debian")) {
            //TODO: Implement checks for Debian packages to find them in the DB
        }
        return -1L;
    }
}

package eu.fasten.analyzer.vulnerabilityplugin.utils;

import org.owasp.dependencycheck.data.nvd.json.DefCveItem;
import org.owasp.dependencycheck.data.nvd.json.Reference;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * This class provides functions to compute stats on vulnerabbilities
 */
public class Stats {

    /**
     * Computes the average CVSS-v3 score of the given list of vulnerabilities.
     * @param vulns - List of vulnerabilities
     * @return floating point average score
     */
    private static float getAvgCVSS3(List<DefCveItem> vulns) {
        float total = 0;
        int number = vulns.size();
        for (DefCveItem item : vulns) {
            if (item.getImpact().getBaseMetricV3() != null) {
                total += item.getImpact().getBaseMetricV3().getCvssV3().getBaseScore();
            } else {
                number -= 1;
            }
        }
        return total / number;
    }

    /**
     * Computes the average CVSS-v2 score of the given list of vulnerabilities.
     * @param vulns - List of vulnerabilities
     * @return floating point average score
     */
    private static float getAvgCVSS2(List<DefCveItem> vulns) {
        float total = 0;
        int number = vulns.size();
        for (DefCveItem item : vulns) {
            if (item.getImpact().getBaseMetricV2() != null) {
                total += item.getImpact().getBaseMetricV2().getCvssV2().getBaseScore();
            } else {
                number -= 1;
            }
        }
        return total / number;
    }

    /**
     * Extracts the vulnerabilities containing a link to a Github commit into the references.
     * @param rawCves - raw list of vulnerabilities
     * @return list of vulnerabilities containing Github commits links
     */
    private static List<DefCveItem> getVulnsWithGitCommits(List<DefCveItem> rawCves) {
        List<DefCveItem> vulns = new ArrayList<>();
        for (DefCveItem cveItem : rawCves) {
            // Adding Patch links, Exploit links or other references
            for (Reference ref : cveItem.getCve().getReferences().getReferenceData()) {
                if (ref.getUrl().matches("https://github\\.com/.*/.*/commit/.*")) {
                    vulns.add(cveItem);
                    break;
                }
            }
        }
        return vulns;
    }

    /**
     * Extracts the vulnerabilities that do NOT contain a link to a Github commit into the references.
     * @param rawCves - raw list of vulnerabilities
     * @return list of vulnerabilities NOT containing Github commits links
     */
    private static List<DefCveItem> getVulnsWithoutGitCommits(List<DefCveItem> rawCves) {
        List<DefCveItem> vulns = new ArrayList<>();
        for (DefCveItem cveItem : rawCves) {
            boolean valid = true;
            // Adding Patch links, Exploit links or other references
            for (Reference ref : cveItem.getCve().getReferences().getReferenceData()) {
                if (ref.getUrl().matches("https://github\\.com/.*/.*/commit/.*")) {
                    vulns.add(cveItem);
                    valid = false;
                    break;
                }
            }
            if (valid) {
                vulns.add(cveItem);
            }
        }
        return vulns;
    }

    /**
     * Counts the number of Github commit links per year.
     * @param rawCves - list of vulnerabilities to process
     * @return hashmap with the number of patches per year (key)
     */
    private static HashMap<Integer, Integer> getPatchCommitsPerYear(List<DefCveItem> rawCves) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 1995; i <= 2020; i++) {
            map.put(i, 0);
        }
        for (DefCveItem cveItem : rawCves) {
            // Adding Patch links, Exploit links or other references
            for (Reference ref : cveItem.getCve().getReferences().getReferenceData()) {
                if (ref.getUrl().matches("https://github\\.com/.*/.*/commit/.*")) {
                    int year = Integer.parseInt(cveItem.getPublishedDate().substring(0, 4));
                    System.out.println(year);
                    if (year > 1995) {
                        map.put(year, map.get(year) + 1);
                    }
                }
            }
        }
        return map;
    }

    /**
     * Counts the number of patch links per year.
     * @param rawCves - list of vulnerabilities to process
     * @return hashmap with the number of patches per year (key)
     */
    private static HashMap<Integer, Integer> getPatchesPerYear(List<DefCveItem> rawCves) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 1995; i <= 2020; i++) {
            map.put(i, 0);
        }
        for (DefCveItem cveItem : rawCves) {
            // Adding Patch links, Exploit links or other references
            for (Reference ref : cveItem.getCve().getReferences().getReferenceData()) {
                if (ref.getTags().contains("Patch")) {
                    int year = Integer.parseInt(cveItem.getPublishedDate().substring(0, 4));
                    if (year > 1995) {
                        map.put(year, map.get(year) + 1);
                    }
                }
            }
        }
        return map;
    }

    /**
     * Computes total number of vulnerabilities per year.
     * @param rawCves - list of vulnerabilities to process
     * @return hashmap containing the count per year
     */
    private static HashMap<Integer, Integer> getCountPerYear(List<DefCveItem> rawCves) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 1995; i <= 2020; i++) {
            map.put(i, 0);
        }
        for (DefCveItem cveItem : rawCves) {
            int year = Integer.parseInt(cveItem.getPublishedDate().substring(0,4));
            System.out.println(year);
            if (year > 1995) {
                map.put(year, map.get(year) + 1);
            }
        }
        return map;
    }
}

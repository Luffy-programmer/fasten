package eu.fasten.analyzer.vulnerabilityplugin;

import eu.fasten.analyzer.vulnerabilityplugin.utils.Parser;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.core.plugins.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.owasp.dependencycheck.data.nvd.json.DefCveItem;
import org.owasp.dependencycheck.utils.DownloadFailedException;
import org.owasp.dependencycheck.utils.ResourceNotFoundException;
import org.owasp.dependencycheck.utils.TooManyRequestsException;
import org.pf4j.Extension;
import org.pf4j.Plugin;
import org.pf4j.PluginWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class VulnerabilityPlugin extends Plugin {

    public VulnerabilityPlugin(PluginWrapper wrapper) {
        super(wrapper);
    }

    @Extension
    public static class VulnerabilityProducer implements KafkaProducer {

        private Logger logger = LoggerFactory.getLogger(getClass());
        String produceTopic = "vulnerability";
        private static org.apache.kafka.clients.producer.KafkaProducer<Object, String>
                kafkaProducer;

        @Override
        public String producerTopic() {
            return this.produceTopic;
        }

        @Override
        public void setKafkaProducer(org.apache.kafka.clients.producer.KafkaProducer<Object, String> producer) {
            kafkaProducer = producer;
        }

        @Override
        public void setProducerTopic(String topicName) {
            this.produceTopic = topicName;
        }

        public void sendToKafka(final String vulnerability) {
            logger.debug("Writing the number " + vulnerability + " to Kafka");
            final ProducerRecord<Object, String> record = new ProducerRecord<Object, String>(
                    this.producerTopic(),
                    vulnerability,
                    vulnerability
            );

            // Callback
            kafkaProducer.send(record, (recordMetadata, e) -> {
                if (recordMetadata != null) {
                    logger.debug("Sent: {} to {}", vulnerability.hashCode(), this.producerTopic());
                } else {
                    setPluginError(e);
                    logger.error("Failed to write message to Kafka: " + e.getMessage(), e);
                }
            });

        }

        @Override
        public String name() {
            return null;
        }

        @Override
        public String description() {
            return null;
        }

        @Override
        public void start() {

            Parser parser = new Parser();
            List<File> paths = null;

            // Step 1: Download all gzip files from NVD
            try {
                paths = Parser.downloadCVEs();
            } catch (MalformedURLException e) {
                System.out.println("URL given is not correct");
            } catch (TooManyRequestsException e) {
                System.out.println("Too many requests");
            } catch (DownloadFailedException e) {
                System.out.println("Download failed");
            } catch (ResourceNotFoundException e) {
                System.out.println("Resource was not found");
            }

            // Step 2: Parse them into DefCveItems
            List<DefCveItem> rawCves = new ArrayList<>();
            try {
                for (File path : paths) {
                    rawCves.addAll(Parser.parseCVEZip(path));
                }
            } catch (IOException e) {
                System.out.println("Error while parsing gzip files");
            }

            // Step 3: Translate into Vulnerability class
            List<Vulnerability> vulnerabilities = Parser.parseVulnerabilities(rawCves);

            // Step 4: Send to Kafka all the vulnerabilities
            for (Vulnerability vulnerability : vulnerabilities) {
                sendToKafka(vulnerability.toString());
            }

            // Step 5: Start a new Thread that checks for updates every day and writes new vulnerabilities
            UpdaterThread ut = new UpdaterThread();
            ut.start();
        }

        @Override
        public void stop() {

        }

        @Override
        public void setPluginError(Throwable throwable) {
            System.out.println("Could not send to Kafka topic");
        }

        @Override
        public String getPluginError() {
            return null;
        }

        @Override
        public void freeResource() {

        }
    }

    static class UpdaterThread implements Runnable {

        Thread thread;

        public void start() {
            thread = new Thread(this);
            thread.start();
        }

        @Override
        public void run() {
            VulnerabilityProducer vp = new VulnerabilityProducer();
            Integer i = 11;
            while (true) {
                vp.sendToKafka(i.toString());
                i += 1;
                try {
                    TimeUnit.SECONDS.sleep(3);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}



package eu.fasten.analyzer.vulnerabilityplugin;

import eu.fasten.analyzer.vulnerabilityplugin.utils.Parser;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.core.plugins.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.json.JSONObject;
import org.owasp.dependencycheck.data.nvd.json.DefCveItem;
import org.owasp.dependencycheck.utils.Settings;
import org.owasp.dependencycheck.utils.Downloader;
import org.pf4j.Extension;
import org.pf4j.Plugin;
import org.pf4j.PluginWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.TimeUnit;

public class VulnerabilityPlugin extends Plugin {

    public VulnerabilityPlugin(PluginWrapper wrapper) {
        super(wrapper);
    }

    @Extension
    public static class VulnerabilityProducer implements KafkaProducer {

        private Logger logger = LoggerFactory.getLogger(getClass());
        private String produceTopic = "vulnerability";
        private String pluginError = "";
        private static org.apache.kafka.clients.producer.KafkaProducer<Object, String>
                kafkaProducer;

        @Override
        public String producerTopic() {
            return this.produceTopic;
        }

        @Override
        public void setKafkaProducer(org.apache.kafka.clients.producer.KafkaProducer<Object, String> producer) {
            kafkaProducer = producer;
        }

        @Override
        public void setProducerTopic(String topicName) {
            this.produceTopic = topicName;
        }

        public void sendToKafka(final String vulnerability) {
            logger.debug("Writing vulnerability to Kafka");
            final ProducerRecord<Object, String> record = new ProducerRecord<Object, String>(
                    this.producerTopic(),
                    vulnerability,
                    vulnerability
            );

            // Callback
            kafkaProducer.send(record, (recordMetadata, e) -> {
                if (recordMetadata != null) {
                    logger.debug("Sent: {} to {}", vulnerability.hashCode(), this.producerTopic());
                } else {
                    setPluginError(e);
                    logger.error("Failed to write message to Kafka: " + e.getMessage(), e);
                }
            });
        }

        @Override
        public String name() {
            return "Vulnerability Plugin";
        }

        @Override
        public String description() {
            return "Vulnerability plugin. "
                    + "Downloads CVE entries from the NVD Database, enriches"
                    + " them with method-level details and publishes to Kafka topic";
        }

        @Override
        public void start() {
            List<File> paths = null;

            // Step 1: Download all gzip files from NVD
            try {
                paths = Parser.downloadCVEs(new Downloader(new Settings(new Properties())));
            } catch (Exception e) {
                logger.error("Unable to download the resources");
            }

            // Step 2: Parse them into DefCveItems
            List<DefCveItem> rawCves = new ArrayList<>();
            try {
                for (File path : paths) {
                    rawCves.addAll(Parser.parseCVEZip(path));
                }
            } catch (IOException e) {
                System.out.println("Error while parsing gzip files");
            }

            // Step 3: Translate into Vulnerability class
            List<Vulnerability> vulnerabilities = Parser.parseVulnerabilities(rawCves);

            // Step 4: Send to Kafka all the vulnerabilities
            for (Vulnerability vulnerability : vulnerabilities) {
                sendToKafka(vulnerability.toString());
            }

            // Step 5: Start a new Thread that checks for updates every day and writes new vulnerabilities
            UpdaterThread ut = new UpdaterThread();
            ut.start();
        }

        @Override
        public void stop() {

        }

        @Override
        public void setPluginError(Throwable throwable) {
            this.pluginError =
                    new JSONObject().put("plugin", this.getClass().getSimpleName()).put("msg",
                            throwable.getMessage()).put("trace", throwable.getStackTrace())
                            .put("type", throwable.getClass().getSimpleName()).toString();
        }

        @Override
        public String getPluginError() {
            return this.pluginError;
        }

        @Override
        public void freeResource() {

        }
    }

    static class UpdaterThread implements Runnable {

        Thread thread;

        public void start() {
            thread = new Thread(this);
            thread.start();
        }

        @Override
        public void run() {
            VulnerabilityProducer vp = new VulnerabilityProducer();
            while (true) {
                try {
                    // Step 1: Sleep for a day
                    TimeUnit.DAYS.sleep(1);

                    // Step 2: Download the NVD modified JSON Feed
                    Downloader downloader = new Downloader(new Settings(new Properties()));
                    File pathToUpdates = Parser.downloadUpdates(downloader);

                    // Step 3: Parse and enqueue the new and the modified entries
                    List<DefCveItem> rawUpdates = Parser.parseCVEZip(pathToUpdates);
                    List<Vulnerability> vulnerabilitiesUpdates = Parser.parseVulnerabilities(rawUpdates);
                    for (Vulnerability vulnerability : vulnerabilitiesUpdates) {
                        vp.sendToKafka(vulnerability.toString());
                    }
                } catch (Exception e) {
                    System.out.println("Could not run updater");
                }
            }
        }
    }
}



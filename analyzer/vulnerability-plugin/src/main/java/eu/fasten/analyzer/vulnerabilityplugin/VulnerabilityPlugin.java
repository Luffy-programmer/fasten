/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin;

import com.mongodb.client.MongoDatabase;
import eu.fasten.analyzer.vulnerabilityplugin.db.MetadataUtility;
import eu.fasten.analyzer.vulnerabilityplugin.db.NitriteController;
import eu.fasten.analyzer.vulnerabilityplugin.utils.connections.JavaHttpClient;
import eu.fasten.analyzer.vulnerabilityplugin.utils.Vulnerability;
import eu.fasten.analyzer.vulnerabilityplugin.utils.mappers.Severity;
import eu.fasten.analyzer.vulnerabilityplugin.utils.parsers.ParserManager;
import eu.fasten.core.plugins.DBConnector;
import eu.fasten.core.plugins.KafkaPlugin;
import eu.fasten.core.plugins.MongoDBConnector;
import org.apache.commons.io.FileUtils;
import org.jooq.DSLContext;
import org.json.JSONArray;
import org.pf4j.Extension;
import org.pf4j.Plugin;
import org.pf4j.PluginWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class VulnerabilityPlugin extends Plugin {

    public VulnerabilityPlugin(PluginWrapper wrapper) {
        super(wrapper);
    }

    @Extension
    public static class VulnerabilityProducer implements KafkaPlugin, DBConnector, MongoDBConnector {

        private String produceTopic = "security";
        private Throwable pluginError = null;
        private ParserManager parserManager;
        private ProducerThread pt;
        private MetadataUtility metadataUtility;
        private MongoDatabase mongoDatabase;
        protected static Queue<Vulnerability> queue = new LinkedList<>();
        private final Logger logger = LoggerFactory.getLogger(VulnerabilityProducer.class.getName());
        private final String pathToNitrite = "./analyzer/vulnerability-plugin/src/main/resources/nitrite/security.db";

        @Override
        public void setDBConnection(DSLContext dslContext) {
            this.metadataUtility = new MetadataUtility(dslContext);
        }

        @Override
        public void setMongoDatabase(MongoDatabase mongoDB) {
            this.mongoDatabase = mongoDB;
        }

        /**
         * Getter necessary to handle stopping of the Updater Thread
         *
         * @return ProducerThread Object that contains an UpdaterThread
         */
        public ProducerThread getProducerThread() {
            return pt;
        }

        /**
         * Setter helps with testing.
         * @param pt
         */
        public void setProducerThread(ProducerThread pt) {
            this.pt = pt;
        }

        public static Queue<Vulnerability> getQueue() {
            return queue;
        }

        @Override
        public String name() {
            return "Vulnerability Plugin";
        }

        @Override
        public String description() {
            return "Vulnerability plugin. "
                    + "Downloads CVE entries from the NVD Database, enriches"
                    + " them with method-level details and publishes to Kafka topic";
        }

        @Override
        public String version() {
            return "1.0";
        }

        /**
         * Sets the connection to Mongodb instance.
         */
        public void createParserManager() {
            logger.info("Creating the ParserManager");
            JavaHttpClient client = new JavaHttpClient();
            NitriteController nc = new NitriteController(pathToNitrite);
            this.parserManager = new ParserManager(client, this.mongoDatabase, nc);
        }

        public MetadataUtility getMetadataUtility() {
            return metadataUtility;
        }

        public void setMetadataUtility(MetadataUtility metadataUtility) {
            this.metadataUtility = metadataUtility;
        }

        /**
         * Helper method to inject the parser in the Plugin.
         * Facilitates testing.
         *
         * @param parser - parser to inject
         */
        public void injectParserManager(ParserManager parser) {
            this.parserManager = parser;
        }

        @Override
        public void start() {
            createParserManager();
            pt = new ProducerThread(queue, parserManager);
            pt.start();
        }

        @Override
        public void stop() {

        }

        public void setPluginError(Throwable throwable) {
            this.pluginError = throwable;
        }

        @Override
        public Throwable getPluginError() {
            return this.pluginError;
        }

        @Override
        public void freeResource() {

        }

        @Override
        public Optional<List<String>> consumeTopic() {
            return Optional.empty();
        }

        @Override
        public void setTopic(String topicName) {
            this.produceTopic = topicName;
        }

        @Override
        public void consume(String record) {
            // do nothing
            // this plugin does not consume from any source
            logger.info("The vulnerability-plugin does not consume");
        }

        @Override
        public Optional<String> produce() {
            while (queue.isEmpty()) {
                // do nothing, waiting for the queue to get some elements
            }
            // Poll it and inject in the DB
            Vulnerability v = queue.poll();
            logger.info("Injecting vulnerability with ID: " + v.getId() + " into the DB");
            metadataUtility.injectVulnerabilityIntoDB(v);
            return Optional.of(v.toJson());
        }

        @Override
        public String getOutputPath() {
            return null;
        }

        /**
         * Reads vulnerabilities from a JSON file.
         * Used for the demo
         * @param jsonPath - Path to JSON file
         * @return List of vulnerabilities
         */
        public static List<Vulnerability> getVulnerabilitiesFromJson(String jsonPath) {
            List<Vulnerability> vulns = new ArrayList<>();
            // Read the content from the file
            File file = new File(jsonPath);
            String raw = null;
            try {
                raw = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (raw == null) return vulns;
            // Parse the JSON
            JSONArray vulnArray = new JSONArray(raw);
            for (int i = 0; i < vulnArray.length(); i++) {
                // Parse the information for each vulnerability
                String cveId = vulnArray.getJSONObject(i).getString("id");
                String publishedDate = vulnArray.getJSONObject(i).getString("published_date");
                String modifiedDate = vulnArray.getJSONObject(i).getString("last_modified_date");
                String description = vulnArray.getJSONObject(i).getString("description");
                Severity severity = Severity.valueOf(vulnArray.getJSONObject(i).getString("severity"));
                Double cvss2 = vulnArray.getJSONObject(i).getDouble("scoreCVSS2");
                Double cvss3 = vulnArray.getJSONObject(i).getDouble("scoreCVSS3");
                List<String> purls = new ArrayList<>();
                JSONArray purlArr = vulnArray.getJSONObject(i).getJSONArray("vulnerable_purls");
                for (int p = 0; p < purlArr.length(); p++) {
                    purls.add(purlArr.getString(p));
                }
                List<String> references = new ArrayList<>();
                JSONArray refArr = vulnArray.getJSONObject(i).getJSONArray("references");
                for (int p = 0; p < refArr.length(); p++) {
                    references.add(refArr.getString(p));
                }
                List<String> patchLinks = new ArrayList<>();
                JSONArray patchArr = vulnArray.getJSONObject(i).getJSONArray("patches");
                for (int p = 0; p < patchArr.length(); p++) {
                    patchLinks.add(patchArr.getString(p));
                }
                List<String> exploits = new ArrayList<>();
                JSONArray explArr = vulnArray.getJSONObject(i).getJSONArray("exploits");
                for (int p = 0; p < explArr.length(); p++) {
                    exploits.add(explArr.getString(p));
                }
                // Reading changed files
                List<Vulnerability.Patch> changedFiles = new ArrayList<>();
                JSONArray files = vulnArray.getJSONObject(i).getJSONArray("changed_files");
                for (int j = 0; j < files.length(); j++) {
                    String filename = files.getJSONObject(j).getString("filename");
                    String fileDate = files.getJSONObject(j).getString("date");
                    List<Integer> lineNumbers = new ArrayList<>();
                    JSONArray numArr = files.getJSONObject(j).getJSONArray("line_numbers");
                    for (int l = 0; l < numArr.length(); l++) {
                        lineNumbers.add(numArr.getInt(l));
                    }

                    Vulnerability.Patch f = new Vulnerability.Patch();
                    f.setFileName(filename);
                    f.setPatchDate(fileDate);
                    f.setLineNumbers(lineNumbers);
                    changedFiles.add(f);
                }
                Vulnerability v = new Vulnerability(cveId);
                v.setDescription(description);
                v.setPublishedDate(publishedDate);
                v.setLastModifiedDate(modifiedDate);
                v.setSeverity(severity);
                v.setScoreCVSS2(cvss2);
                v.setScoreCVSS3(cvss3);
                v.setPurls(new HashSet<>(purls));
                v.setPatchLinks(new HashSet<>(patchLinks));
                v.setExploits(new HashSet<>(exploits));
                v.setReferences(new HashSet<>(references));
                v.setPatches(new HashSet<>(changedFiles));

                vulns.add(v);
            }
            return vulns;
        }
    }

    static class ProducerThread implements Runnable {

        Thread thread;
        Logger logger = LoggerFactory.getLogger(getClass());
        Queue<Vulnerability> queue;
        ParserManager parser;
        UpdaterThread ut;

        public ProducerThread(Queue<Vulnerability> queue, ParserManager parser) {
            this.queue = queue;
            this.parser = parser;
        }

        public UpdaterThread getUpdater() {
            return ut;
        }

        public void start() {
            logger.info("Started ProducerThread");
            thread = new Thread(this);
            thread.start();
        }

        @Override
        public void run() {
            // Get all the vulnerabilities from the Parsers and enqueue them
            logger.info("Gathering information from all parsers");
            HashSet<Vulnerability> vulnerabilities = parser.getVulnerabilitiesFromParsers();
            logger.info("Received a total of " + vulnerabilities.size() + " vulnerabilities from the ParserManager.");
            for (Vulnerability v : vulnerabilities) {
                // Add it to the queue to publish to Kafka
                queue.add(v);
            }

            // Start a new Thread that checks
            // for updates every day and writes new vulnerabilities
            logger.info("Starting the Updater Thread");
            ut = new UpdaterThread(queue, parser);
            ut.start();
        }
    }

    static class UpdaterThread implements Runnable {

        Thread thread;
        Queue<Vulnerability> queue;
        ParserManager parser;
        Logger logger = LoggerFactory.getLogger(getClass());
        private volatile boolean exit = false;

        public UpdaterThread(Queue<Vulnerability> queue, ParserManager parser) {
            this.queue = queue;
            this.parser = parser;
        }

        public void start() {
            thread = new Thread(this);
            thread.start();
        }

        public void terminate() {
            exit = true;
        }

        @Override
        public void run() {
            while (!exit) {
                try {
                    // Step 1: Sleep for a day
                    // Injected into parser logic in order to test
                    parser.sleep();

                    // Get updates and inject them as well
                    HashSet<Vulnerability> updates = parser.getUpdatesFromParsers();
                    for (Vulnerability v : updates) {
                        queue.add(v);
                    }
                } catch (Exception e) {
                    System.out.println("Could not run updater");
                }
            }
        }
    }
}



/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityplugin.utils.mappers;

import java.util.*;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import eu.fasten.analyzer.vulnerabilityplugin.utils.connections.JavaHttpClient;
import org.json.JSONObject;
import org.w3c.dom.*;
import org.xml.sax.InputSource;

import javax.xml.parsers.*;
import java.io.*;

public class VersionRanger {

    JavaHttpClient client;
    ObjectMapper mapper;
    // MAVEN encoding: /maven/<group_id>/<artifact_id>
    // PYPI encoding: /pypi/<package_name>
    public HashMap<String, List<String>> versionsMappings;

    /**
     * Constructor to inject the client
     * @param client - in order to perform requests
     * @param pathToJson - path to the JSON file to keep the data already gathered
     *                     e.g. "./analyzer/vulnerability-plugin/src/main/resources/trackers/package_versions.json"
     */
    public VersionRanger(JavaHttpClient client, String pathToJson) {
        this.client = client;
        this.mapper = new ObjectMapper();
        this.versionsMappings = loadVersionsFromJson(pathToJson);
    }

    /**
     * Loads the versions already found from the JSON.
     * @param path of the JSON file where the versions are stored
     * @return hashmap with the versions already stored
     */
    public HashMap<String, List<String>> loadVersionsFromJson(String path) {
        File versions = new File(path);
        if (versions.exists()) {
            try {
                return mapper.readValue(new File(
                        versions.getPath()), new TypeReference<HashMap<String, List<String>>>() {
                });
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return new HashMap<>();
    }

    /**
     * Retrieves all available versions of a specific package.
     * @param mvnPackage - String that identifies the package to retrieve versions from
     *                   The following format is supported: "/maven/<group_id>/<artifact_id>"
     */
    public List<String> injectVersionsMavenPackage(String mvnPackage) {
        String[] splitter = mvnPackage.split("/");
        String groupId = splitter[2].strip();
        String artifactId = splitter[3].strip();
        String[] groupSplits = groupId.split("\\.");
        StringBuilder sb = new StringBuilder("https://repo1.maven.org/maven2/");
        for (String gsplit : groupSplits) {
            sb.append(gsplit + "/");
        }
        sb.append(artifactId + "/");
        sb.append("maven-metadata.xml");
        String mvnUrl = sb.toString();
        List<String> versions = new ArrayList<>();
        try {
            String details = client.sendGet(mvnUrl);
            if (details.contains("404 Not Found")) {
                // This works for some apache packages
                String clientsUrl = mvnUrl.substring(0, mvnUrl.length() - 19) + "-clients/maven-metadata.xml";
                details = client.sendGet(clientsUrl);
                if (details.contains("404 Not Found")) {
                    return null;
                }
            }
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.parse(new InputSource(new StringReader(details)));
            Element root = document.getDocumentElement();
            NodeList versionsNodes = root.getElementsByTagName("version");
            for (int i = 0; i < versionsNodes.getLength(); i++) {
                String version = versionsNodes.item(i).getTextContent();
                versions.add(version);
            }
            versionsMappings.put(mvnPackage, versions);
            return versions;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Retrieves all available versions of a specific package.
     * @param pypiPackage - String that identifies the package to retrieve versions from
     *                   The following format is supported: "/pypi/<package_name>"
     */
    public List<String> injectVersionsPyPiPackage(String pypiPackage) {
        String[] splitter = pypiPackage.split("/");
        List<String> versions = new ArrayList<>();
        String packageName = splitter[2].strip();
        try {
            String details = client.sendGet("https://pypi.org/pypi/"+ packageName + "/json");
            if (details.contains("We looked everywhere but couldn't find this page") || details.contains("404 Not Found")) {
                return null;
            }
            JSONObject obj = new JSONObject(details);
            // TreeSet keeps versions sorted
            TreeSet<String> releases = new TreeSet(obj.getJSONObject("releases").keySet());
            for (String s : releases) {
                versions.add(s);
            }
            versionsMappings.put(pypiPackage, versions);
            return versions;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * This method takes an encoded version range of a vulnerable range and all the versions of a package.
     * It returns a list of versions that are vulnerable
     * @param encodedRangeVersions
     * <=0.0.2 - all versions less or equal to 0.0.2 are vulnerable
     * <=1.4.7,1.4 - versions from 1.4 to 1.4.7 are vulnerable
     * ==2.1.4 - the exact version is vulnerable
     * @param allVersions - list all versions of a package
     * @return a list of vulnerable versions
     */
    public List<String> getVulnerableVersionsYAML(List<String> encodedRangeVersions, List<String> allVersions) {
        List<String> vulnerableVersions = new ArrayList<>();
        for (String encodedRange : encodedRangeVersions) {
            // Parse the first two characters, they should be either "<=" or "=="
            String operator = encodedRange.substring(0, 3);
            if (operator.equals("==")) {
                vulnerableVersions.add(encodedRange.substring(2));
            }
            if (operator.equals("<=")) {
                String endpointsRange = encodedRange.substring(2);
                String[] endpoints = endpointsRange.split(",");
                String startingFrom = endpoints[1];
                String endingAt = endpoints[0];

                int indexStart = allVersions.indexOf(startingFrom);
                int indexEnd = allVersions.indexOf(endingAt);

                for (int i = indexStart; i <= indexEnd; i++) {
                    vulnerableVersions.add(allVersions.get(i));
                }
            }
        }
        return vulnerableVersions;
    }

    /**
     * Returns a vulnerable range of versions based on the encoding given.
     * @param encodedRangeVersions
     * @param allVersions
     * @return
     */
    public List<String> getVulnerableVersionsJSON(String[] encodedRangeVersions, List<String> allVersions) {
        List<String> vulnerableVersions = new ArrayList<>();
        // 1 is for vulnerable and 0 for not vulnerable
        int[] affectedVersions = new int[allVersions.size()];
        for (String range : encodedRangeVersions) {
            String regex = "[0-9]";
            String operator = range.split(regex)[0];
            String version = range.substring(operator.length());
            if (operator.equals("==")) {
                if (allVersions.indexOf(version) >= 0) {
                    affectedVersions[allVersions.indexOf(version)] = 1;
                }
            }
            if (operator.equals("<=")) {
                int startIndex = allVersions.indexOf(version);
                if (startIndex >= 0) {
                    for (int i = 0; i <= startIndex; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            if (operator.equals("<")) {
                int startIndex = allVersions.indexOf(version) - 1;
                if (startIndex >= 0) {
                    for (int i = 0; i <= startIndex; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            if (operator.equals(">=")) {
                int startIndex = allVersions.indexOf(version);
                if (startIndex >= 0) {
                    for (int i = startIndex; i < affectedVersions.length; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            if (operator.equals(">")) {
                int startIndex = allVersions.indexOf(version) + 1;
                if (startIndex >= 0) {
                    for (int i = startIndex; i < affectedVersions.length; i++) {
                        affectedVersions[i] = 1;
                    }
                }
            }
            for (int i = 0; i < affectedVersions.length; i++) {
                if (affectedVersions[i] == 1) {
                    vulnerableVersions.add(allVersions.get(i));
                }
            }
        }
        return vulnerableVersions;
    }

        /**
         * Helper to build PURLs based on this specification: https://github.com/package-url/purl-spec
         * maven: /maven/<group_id>/<artifact_id>@version
         * @param javaPgk - object containing information about the package
         * @param vulnerableVersions - list of vulnerable versions
         * @return a set of purls
         */
    public HashSet<String> buildPURLSMaven(YAMLHandler.JavaPgkMapper javaPgk, List<String> vulnerableVersions) {
        HashSet<String> purls = new HashSet<>();
        String groupId = javaPgk.groupId;
        String artifactId = javaPgk.artifactId;
        for (String version : vulnerableVersions) {
            String purl = "/maven/" + groupId + "/" + artifactId + "@" + version;
            purls.add(purl);
        }
        return purls;
    }

    /**
     * Helper to build PURLs based on this specification: https://github.com/package-url/purl-spec
     * pypi: /pypi/<package_name>@version
     * @param pythonPgk - object containing information about the package
     * @param vulnerableVersions - list of vulnerable versions
     * @return a set of purls
     */
    public HashSet<String> buildPURLSPypi(YAMLHandler.PythonPgkMapper pythonPgk, List<String> vulnerableVersions) {
        HashSet<String> purls = new HashSet<>();
        String packageName = pythonPgk.name;
        for (String version : vulnerableVersions) {
            String purl = "/pypi/" + packageName + "@" + version;
            purls.add(purl);
        }
        return purls;
    }

    /**
     * Method returns versions of the package encoded in input.
     * If the versions were previously retrieved it uses those, otherwise retrieves them from source.
     * @param pgk - encoding of the package to retrieve information from:
     *            maven: /maven/<group_id>/<artifact_id>
     *            pypi: /pypi/<package_name>
     * @return list of versions of the package
     */
    public List<String> getVersions(String pgk) {
        if (versionsMappings.get(pgk) != null) {
            return versionsMappings.get(pgk);
        }
        if (pgk.matches("/maven/.*")) {
            return injectVersionsMavenPackage(pgk);
        }
        if (pgk.matches("/pypi/.*")) {
            return injectVersionsPyPiPackage(pgk);
        }
        return null;
    }

    /**
     * @param pathToWrite - path to write the file to
     * Writes all the mappings gathered so far in the file packages.versions.
     * e.g. "./analyzer/vulnerability-plugin/src/main/resources/trackers/package_versions.json"
     */
    public void writeVersions(String pathToWrite) {
        ObjectMapper mapper = new ObjectMapper();
        try {
            mapper.writeValue(new File(pathToWrite), versionsMappings);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * In the grand schema of the plugin, this method will be called before the daily update.
     * This allows to have all the versions up-to-date
     */
    public void updateMappings() {
        Set<String> keys = versionsMappings.keySet();
        for (String pgk : keys) {
            if (pgk.matches("/maven/*")) {
                injectVersionsMavenPackage(pgk);
            }
            if (pgk.matches("/pypi/*")) {
                injectVersionsPyPiPackage(pgk);
            }
        }
    }
}
